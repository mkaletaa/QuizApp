[
  {
    "data": [
      {
        "type": "Text",
        "value": "Tutaj znajdują się zadania, które tematyką nie wpasowują się bezpośrednio w żaden z wcześniejszych tematów. "
      }
    ]
  },
  {
    "title": "osiem hetmanów",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/GpL63ZBy/image.png",
        "props": { "description": "2016, 2022" }
      },
      {
        "type": "YouTube",
        "value": "dUVZEWQA78s"
      },
      {
        "type": "Text",
        "value": "<b>Problem ośmiu hetmanów</b>: zadanie polegajace na ustawieniu na szachownicy ośmiu hetmanów tak, aby żaden z nich nie mógł zbić innego."
      },
      {
        "type": "Text",
        "value": "<b>Problem skoczka szachowego</b>: zadanie polegające na obejściu wszystkich pól planszy w ten sposób, by na każdym polu stanąć dokładnie raz."
      },
      {
        "type": "Text",
        "value": "<b>Algorytm z nawrotami</b> (ang. backtracking) – ogólny algorytm wyszukiwania wszystkich (lub kilku) rozwiązań niektórych problemów obliczeniowych, który stopniowo generuje kandydatów na rozwiązanie, jednak gdy stwierdzi, że znaleziony kandydat c nie może być poprawnym rozwiązaniem, nawraca (ang. backtracks) do punktu, gdzie może podjąć inną decyzję związaną z jego budową"
      },
      {
        "type": "Header",
        "value": "omówienie backtrackingu w kontekście hetmanów",
        "props": { "size": "sm" }
      },
      {
        "type": "BulletPoint",
        "value": "<b>1.</b> Umieść pierwszego hetmana w pierwszym wierszu pierwszej kolumny."
      },
      {
        "type": "BulletPoint",
        "value": "<b>2.</b> Umieść kolejnego hetmana w kolejnej kolumnie i sprawdź czy nie zagraża poprzednim hetmanom. Jeśli zagraża, przesuń go o jeden wiersz pozostając w tej samej kolumnie. Jeśli żaden wiersz kolumny się nie nadaje, wróć do poprzedniej kolumny i przesuń tam hetmana do następnego wiersza. Jeśli w poprzedniej kolumnie również nie ma możliwego ruchu, cofnij się o jeszcze jedną kolumnę, i tak dalej, aż znajdziesz bezpieczne miejsce."
      },
      {
        "type": "BulletPoint",
        "value": "<b>3.</b> Kontynuuj punkt 2, aż wszystkie hetmany zostaną bezpiecznie umieszczone na szachownicy lub zostanie potwierdzone, że żadne rozwiązanie nie istnieje."
      },
      {
        "type": "Header",
        "value": "przykłady rozwiązania",
        "props": { "size": "sm" }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/7PCx3TKW/het.png"
      },
      {
        "type": "Header",
        "value": "porównanie złożoności",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "Złożoność czasowa problemu ośmiu hetmanów w najgorszym przypadku wynosi 8! = 40320 możliwych permutacji. W problemie skoczka figura ta ma 8 możliwych ruchów z każdego pola, a na szachownicy jest ich 64, więc złożoność tego problemu wynosi 8^64. A zatem problem skoczka szachowego ma o wiele większą złożoność czasową dla najgorszego przypadku."
      }
    ]
  },
  {
    "title": "stos Łukasiewicza",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/pXGBnrLk/image.png",
        "props": { "description": "2020, 2023 poprawa, 2024" }
      },
      {
        "type": "Text",
        "value": "Tutaj masz podaną liczbę zapisaną w systemie ósemkowym i ją zamieniasz na dziesiętny."
      },
      {
        "type": "Math",
        "value": "`3246571_8 = 3*8^6 + 2*8^5 + 4*8^4 + 6*8^3 + 5*8^2 + 7*8^1 + 1*8^0 = 871801_{10}`"
      },
      {
        "type": "Text",
        "value": "Jawne użycie stosu może zapobiec jego przepełnieniu podczas wykonywania algorytmu, ponieważ pozwala na lepszą kontrolę nad zarządzaniem pamięcią i śledzeniem stanu rekursji. Przepełnienie stosu (ang. stack overflow) następuje, gdy rekurencja jest zbyt głęboka i przekracza ograniczenia pamięci stosu. Poprzez jawne użycie stosu zamiast polegania na automatycznej rekurencji, można wprowadzić pewne optymalizacje i techniki zarządzania pamięcią, które zmniejszają ryzyko przepełnienia. "
      }
    ]
  },
  {
    "title": "Fibonacci",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/ZKbWzLZD/image.png",
        "props": { "description": "2022" }
      },
      {
        "type": "Text",
        "value": "Rekursja drzewiasta to rodzaj rekurencji, w której rozwiązanie problemu wymaga rozwiązania wielu podproblemów, a każdy z tych podproblemów może rozgałęziać się dalej. Jest to typowa cecha algorytmów rekurencyjnych, gdzie podproblemy są identyczne lub podobne do oryginalnego problemu, a ich liczba rośnie wykładniczo wraz z rozmiarem problemu. <br></br>Oto jak wygląda drzewko rekurencji drzewiastej podczas obliczania liczby Fibonacciego F(6):"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/L557PjDH/image.png"
      },
      {
        "type": "Text",
        "value": "Zauważmy, że F(3), F(2), F(1) są obliczane wielokrotnie. F(3) jest obliczane trzy razy, F(2) i F(1) pięć razy. A zatem rekursja drzewiasta jest nieefektywna, bo powoduje wielokrotne obliczanie tych samych wartości, co prowadzi do ogromnej liczby zbędnych obliczeń."
      },
      {
        "type": "Text",
        "value": "W metodzie tablicowej używamy tablicy do zapamiętania wyników obliczeń podproblemów, co eliminuje potrzebę ich wielokrotnego liczenia. Dla F(6) za pomocą programowania dynamicznego, każdy wynik jest obliczany tylko raz, a kolejne wartości są dodawane do tablicy"
      }
    ]
  },
  {
    "title": "liczby Stirlinga",
    "data": [
      {
        "type": "Header",
        "value": "Wypełnij tablicę dwuwymiarową zawierające liczby Stirlinga drugiego rodzaju. Przeprowadź analizę złożoności rekursji w strukturach drzewiastych na podstawie liczb Stirlinga drugiego rodzaju. Udowodnij nieefektywność takiej rekursji. - 2016, 2018, 2020",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "Liczby Stirlinga drugiego rodzaju oznaczamy jako S(n,k) i odpowiadają na pytanie: \"Ile jest sposobów podziału zbioru o n elementach na k niepustych podzbiorów?\" Na przykład S(3, 2) = 3 co oznacza, że istnieją 3 różne sposoby podziału zbioru 3-elementowego na 2 grupy. Są to: <br></br>{1} i {2, 3}; <br></br>{1, 2} i {3}; <br></br>{1, 3} i {2}."
      },
      {
        "type": "Header",
        "value": "charakterystyczne wzory:",
        "props": { "size": "sm" }
      },
      {
        "type": "BulletPoint",
        "value": "S(n,n)=1: Istnieje tylko jeden sposób podziału n-elementowego zbioru na n grup, każda grupa zawierająca jeden element."
      },
      {
        "type": "BulletPoint",
        "value": "S(n,1)=1: Istnieje tylko jeden sposób podziału n-elementowego zbioru na 1 grupę, gdzie wszystkie n elementów są w jednej grupie."
      },
      {
        "type": "BulletPoint",
        "value": "S(n,k)=0 dla k>n: Nie da się podzielić zbioru na więcej niepustych podzbiorów niż liczba elementów w tym zbiorze."
      },
      {
        "type": "BulletPoint",
        "value": "S(0,0)=1"
      },
      {
        "type": "BulletPoint",
        "value": "S(n,k) = k⋅S(n-1, k) + S(n-1, k-1)"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/Y0BkXjsK/image.png",
        "props": {
          "description": "tablica dwuwymiarowa z liczbami Stirlinga drugiego rodzaju"
        }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/tJnZ61nK/image.png",
        "props": { "description": "drzewko liczb Stirlinga" }
      },
      {
        "type": "Text",
        "value": "Widzimy, że niektóre z tych liczb są obliczane wielokrotnie, np S(1,1), S(1,0)"
      }
    ]
  }

]
