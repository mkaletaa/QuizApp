[
  {
    "title": "programowanie dynamiczne",
    "data": [
      {
        "type": "Text",
        "value": "Problem plecakowy jest przykładem programowania dynamicznego. Jest to sposób projektowania algorytmów wymyślony przez Richarda Bellmana, stosowany przeważnie do rozwiązywania zagadnień optymalizacyjnych. Opiera się na podziale rozwiązywanego problemu na podproblemy względem kilku parametrów. Konstrukcja programu wykorzystującego zasadę programowania dynamicznego może być sformułowana w trzech etapach: koncepcji inicjacji i progresji. <a href='https://pdfhost.io/v/sddQgRZ9~_pr_dynamiczne'>Więcej info (pdf)</a>"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/HkCCZVLt/image.png"
      },
      {
        "type": "Text",
        "value": "Rozwiązanie problemu plecakowego jest przykładem programowania dynamicznego, bo problem jest dzielony na podproblemy - analizujemy najpierw jaki byłby wynik dla mniejszych nośności plecaka i mniejszych zbiorów przedmiotów, a potem stopniowo je zwiększamy, aż dochodzimy do ostatecznego wyniku."
      }
    ]
  },
  {
    "title": "bez nawrotów",
    "data": [
      {
        "type": "Text",
        "value": "Hindus ci wszystko wytłumaczy."
      },
      {
        "type": "YouTube",
        "value": "nLmhmB6NzcM"
      },
      {
        "type": "Text",
        "value": "Jedyna różnica jest taka, że on nie bierze pod uwagę, że można zapakować do plecaka więcej niż jedną sztukę jakiegoś przedmiotu - czyli rozpatruje odmianę problemu plecakowego o nazwie 0/1 knapsack problem. Na labach mamy mniej popularną wersję o nazwie unbounded knapsack problem, która pozwala na pakowanie wielu sztuk tego samego przedmiotu. No i nas jeszcze uczą żeby zbudować jakąś drugą tabelkę, która ma niby przechowywać wybrane przedmioty. Z tego co patrzę po necie, to w zasadzie nikt tego nie robi."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/MKRfCzMt/image.png",
        "props": { "description": "2023" }
      },
      {
        "type": "Text",
        "value": "Po prawej stronie od tabeli zapisywałem jakie przedmioty składają się na ostanią komórkę każdego wiersza. Rozwiązanie znajduje się oczywiście w ostatnim wierszu."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/rshV4cTr/image.png",
        "props": { "description": "metodą Hindusa (0/1 knapsack)" }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/g2LzxfTx/image.png",
        "props": { "description": "metodą Nowakowskiego (unbounded knapsack)" }
      },
      {
        "type": "Text",
        "value": "Czyli jeśli możemy zapakować tylko jeden przedmiot danego rodzaju to wynikiem jest 45 (przedmiot p1, p2 i p3). Jeśli przyjmiemy, że można pakować więcej niż jedną sztukę danego przedmiotu to wynik to 50 (pięć przedmiotów p1 lub dwa przedmioty p1 i dwa przedmioty p2). Który z tych sposobów użyć do rozwiązania zadania? Uczą nas tego drugiego, więc raczej jego.<br></br>No i pozostaje kwestia tej drugiej, pomocniczej tabelki. Tam chyba zapisujesz indeks przedmiotu włożonego do plecaka, który znajduje się najniżej w tabeli. W sumie nie wiem po co to jest bo można obejść sie bez tego. Niżej zamieszczam przykład z ćwiczeń."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/XvvJYWJR/image.png"
      }
    ]
  },
  {
    "title": "z nawrotami",
    "data": [
      {
        "type": "Text",
        "value": "Nigdy się nie pojawił na egzaminie, pewnie dlatego, że jest zbyt dojebany i obliczenie tego wszystkiego zajęłoby połowę czasu. Ale kto wie, może kiedyś będzie ten pierwszy raz."
      },
      {
        "type": "Text",
        "value": "Rozwiązanie z nawrotami też wymaga zbudowania tabelki, ale pierwsze skrzypce gra drzewko binarne. Przedmioty w tabeli muszą być ułożone w taki sposób, że najwyżej znajduje się ten, którego stosuenk wartości p do wagi w jest największy, a im niżej, tym ten stosunek staje się mniejszy.<br></br>Algorytm składa się z kilku kroków:<br></br><b>1)</b> policz profit p i wagę w zapakowanych przedmiotów.<br></br><b>2)</b> porównaj w z maksymalną wagą W jaka może zmieścić się do plecaka. Jeśli w < W to węzeł jest obiecujący, liczymy dalej. Jeśli w >= W to węzeł nie jest obiecujący, cofamy się na drzewku i zaczynamu kroki algorytmu od nowa.<br></br><b>3)</b> wyznaczamy k oraz i. k to indeks przedmiotu, dla którego przekroczymy nośność plecaka W. Zaś i to poziom drzewa, na którym się aktualnie znajdujemy.<br></br><b>4)</b> oblicz totalweight ze wzoru:"
      },
      {
        "type": "Math",
        "value": "`\"totweight\" = w + sum_(j=i+1)^(k-1) w_j`"
      },
      {
        "type": "Text",
        "value": "<b>5)</b> Oblicz bound ze wzoru:"
      },
      {
        "type": "Math",
        "value": "`bound = profit + sum_(j=i+1)^(k-1) p_j + (w - \"totweight\")*(p_k/w_k)`"
      },
      {
        "type": "Text",
        "value": "Jeżeli bound > max_profit to węzeł jest obiecujący i przechodzimy do jego dziecka. Jeśli nie, znaczy że węzeł jest nieobiecujący i trzeba się cofnąć."
      },
      {
        "type": "Text",
        "value": "Ten algorytm jest w chuj dojebany i dokładniejsze go opisanie + rozpisanie przykładowego zadania zajęłoby mi z tydzień, więc dam linka do pdf-a, gdzie są obliczenia dla pierwszych kilku węzłów i końcowe drzewko. <a href='https://pdfhost.io/v/EX63gGCQB_Przyklad_z_Laboratorium'>Klikaj tu</a>"
      }
    ]
  },
  {
    "title": "partition problem",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/y81f3m82/image.png",
        "props": { "description": "2017, 2018, ?" }
      },
      {
        "type": "Text",
        "value": "W tym zadaniu chodzi o to, żeby podzielić ten zbiór na dwa podzbiory, w których suma liczb będzie taka sama. Na przykład dla zbioru S={1, 5, 11, 5} rozwiązaniem będzie S<sub>1</sub>={1, 5, 5} S<sub>2</sub>={11}. Co to ma wspólnego z problemem plecakowym? Okazuje się, że partition problem jest zagadnieniem z dziedziny programowania dynamicznego i można go rozwiązać tak samo jak rozwiazuje się 0/1 knapsack problem! Wystarczy, że potraktujemy liczby a<sub>1</sub> - a<sub>5</sub> jako przedmioty, których wartość i waga są równe wartościom tych liczb, a maksymalna nośność plecaka jest równa połowie sumy liczb. "
      },
      {
        "type": "Text",
        "value": "Na początek obliczamy sumę, u nas wynosi ona 20. Gdyby się okazało, że jest nieparzysta to znaczy, że zadanie nie ma rozwiązania, bo oczywiście nie da się podzielić liczby nieparzystej na dwie równe całkowite liczby. Potem rysujemy tabelę i przystępujemy do jej uzupełniania."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/4d2GjfFx/image.png"
      },
      {
        "type": "Text",
        "value": "Zauważ, że nie trzeba nawet uzupełniać tabeli do końca, bo juz w przedostatnim wierszu ostatnia jego komórka ma porządaną przez nas wartość czyli 10. Rozwiązaniem tego zadania jest S<sub>1</sub>={a<sub>5</sub>=1, a<sub>2</sub>=4, a<sub>4</sub>=5} S<sub>2</sub>={a<sub>3</sub>=3, a<sub>1</sub>=7}"
      }
    ]
  }
]
