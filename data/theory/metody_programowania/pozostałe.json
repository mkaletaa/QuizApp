[
  {
    "data": [
      {
        "type": "Text",
        "value": "Tutaj znajdują się zadania, które tematyką nie wpasowują się w żadne z omawianych na laboratoriach zagadnień. "
      }
    ]
  },
  {
    "title": "osiem hetmanów",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/GpL63ZBy/image.png",
        "props": { "description": "2016, 2022" }
      },
      {
        "type": "YouTube",
        "value": "dUVZEWQA78s"
      },
      {
        "type": "Text",
        "value": "<b>Problem ośmiu hetmanów</b>: zadanie polegajace na ustawieniu na szachownicy ośmiu hetmanów tak, aby żaden z nich nie mógł zbić innego."
      },
      {
        "type": "Text",
        "value": "<b>Problem skoczka szachowego</b>: zadanie polegające na obejściu wszystkich pól planszy w ten sposób, by na każdym polu stanąć dokładnie raz."
      },
      {
        "type": "Text",
        "value": "<b>Algorytm z nawrotami</b> (ang. backtracking) – ogólny algorytm wyszukiwania wszystkich (lub kilku) rozwiązań niektórych problemów obliczeniowych, który stopniowo generuje kandydatów na rozwiązanie, jednak gdy stwierdzi, że znaleziony kandydat c nie może być poprawnym rozwiązaniem, nawraca (ang. backtracks) do punktu, gdzie może podjąć inną decyzję związaną z jego budową"
      },
      {
        "type": "Header",
        "value": "omówienie backtrackingu w kontekście hetmanów",
        "props": { "size": "sm" }
      },
      {
        "type": "BulletPoint",
        "value": "Zacznij od pierwszej kolumny i próbuj umieszczać hetmana w pierwszym wierszu. Sprawdź, czy umieszczenie hetmana w danym wierszu nie zagraża wcześniej umieszczonym hetmanom. Jeśli nie ma zagrożenia, przejdź do następnej kolumny i próbuj umieszczać kolejnego hetmana."
      },
      {
        "type": "BulletPoint",
        "value": "Jeśli nie możesz umieścić hetmana w żadnym wierszu aktualnej kolumny (bo wszystkie są zablokowane przez inne hetmany), wróć do poprzedniej kolumny i przesuń tam hetmana do następnego wiersza. Jeśli w poprzedniej kolumnie również nie ma możliwego ruchu, cofnij się o jeszcze jedną kolumnę, i tak dalej, aż znajdziesz bezpieczne miejsce lub dojdziesz do punktu, gdzie nie ma możliwego rozwiązania."
      },
      {
        "type": "BulletPoint",
        "value": "Kontynuuj proces, aż wszystkie hetmany zostaną bezpiecznie umieszczone na szachownicy lub zostanie potwierdzone, że żadne rozwiązanie nie istnieje."
      },
      {
        "type": "Header",
        "value": "przykłady rozwiązania",
        "props": { "size": "sm" }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/7PCx3TKW/het.png"
      },
      {
        "type": "Header",
        "value": "porównanie złożoności",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "Złożoność czasowa problemu ośmiu hetmanów w najgorszym przypadku wynosi 8! = 40320 możliwych permutacji. W problemie skoczka figura ta ma 8 możliwych ruchów z każdego pola, a szachownicy jest 64, więc złożoność tego problemu wynosi 8^64. A zatem problem skoczka szachowego ma o wiele większą złożoność czasową dla najgorszego przypadku."
      }
    ]
  },
  {
    "title": "stos Łukasiewicza",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/pXGBnrLk/image.png",
        "props": { "description": "2020, 2023 poprawa, 2024" }
      },
      {
        "type": "Text",
        "value": "Tutaj masz podaną liczbę zapisaną w systemie ósemkowym i ją zamieniasz na dziesiętny."
      },
      {
        "type": "Math",
        "value": "`3246571_8 = 3*8^6 + 2*8^5 + 4*8^4 + 6*8^3 + 5*8^2 + 7*8^1 + 1*8^0 = 871801_{10}`"
      },
      {
        "type": "Text",
        "value": "Jawne użycie stosu może zapobiec jego przepełnieniu podczas wykonywania algorytmu, ponieważ pozwala na lepszą kontrolę nad zarządzaniem pamięcią i śledzeniem stanu rekursji. Przepełnienie stosu (ang. stack overflow) następuje, gdy rekurencja jest zbyt głęboka i przekracza ograniczenia pamięci stosu. Poprzez jawne użycie stosu zamiast polegania na automatycznej rekurencji, można wprowadzić pewne optymalizacje i techniki zarządzania pamięcią, które zmniejszają ryzyko przepełnienia. "
      }
    ]
  },
  {
    "title": "rekurencja drzewiasta",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/ZKbWzLZD/image.png",
        "props": { "description": "2022" }
      },
      {
        "type": "Text",
        "value": "Rekursja drzewiasta to rodzaj rekurencji, w której rozwiązanie problemu wymaga rozwiązania wielu podproblemów, a każdy z tych podproblemów może rozgałęziać się dalej. Jest to typowa cecha algorytmów rekurencyjnych, gdzie podproblemy są identyczne lub podobne do oryginalnego problemu, a ich liczba rośnie wykładniczo wraz z rozmiarem problemu."
      },
      {
        "type": "Text",
        "value": "dokończyć"
      }
    ]
  }
]
