[
  {
    "data": [
      {
        "type": "Text",
        "value": "Tutaj znajdują się zadania, które tematyką nie wpasowują się bezpośrednio w żaden z wcześniejszych tematów. "
      }
    ]
  },
  {
    "title": "osiem hetmanów",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/GpL63ZBy/image.png",
        "props": { "description": "2016, 2022" }
      },
      {
        "type": "YouTube",
        "value": "dUVZEWQA78s"
      },
      {
        "type": "Text",
        "value": "<b>Problem ośmiu hetmanów</b>: zadanie polegajace na ustawieniu na szachownicy ośmiu hetmanów tak, aby żaden z nich nie mógł zbić innego."
      },
      {
        "type": "Text",
        "value": "<b>Problem skoczka szachowego</b>: zadanie polegające na obejściu wszystkich pól planszy w ten sposób, by na każdym polu stanąć dokładnie raz."
      },
      {
        "type": "Text",
        "value": "<b>Algorytm z nawrotami</b> (ang. backtracking) – ogólny algorytm wyszukiwania wszystkich (lub kilku) rozwiązań niektórych problemów obliczeniowych, który stopniowo generuje kandydatów na rozwiązanie, jednak gdy stwierdzi, że znaleziony kandydat c nie może być poprawnym rozwiązaniem, nawraca (ang. backtracks) do punktu, gdzie może podjąć inną decyzję związaną z jego budową"
      },
      {
        "type": "Header",
        "value": "omówienie backtrackingu w kontekście hetmanów",
        "props": { "size": "sm" }
      },
      {
        "type": "BulletPoint",
        "value": "<b>1.</b> Umieść pierwszego hetmana w pierwszym wierszu pierwszej kolumny."
      },
      {
        "type": "BulletPoint",
        "value": "<b>2.</b> Umieść kolejnego hetmana w kolejnej kolumnie i sprawdź czy nie zagraża poprzednim hetmanom. Jeśli zagraża, przesuń go o jeden wiersz pozostając w tej samej kolumnie. Jeśli żaden wiersz kolumny się nie nadaje, wróć do poprzedniej kolumny i przesuń tam hetmana do następnego wiersza. Jeśli w poprzedniej kolumnie również nie ma możliwego ruchu, cofnij się o jeszcze jedną kolumnę, i tak dalej, aż znajdziesz bezpieczne miejsce."
      },
      {
        "type": "BulletPoint",
        "value": "<b>3.</b> Kontynuuj punkt 2, aż wszystkie hetmany zostaną bezpiecznie umieszczone na szachownicy lub zostanie potwierdzone, że żadne rozwiązanie nie istnieje."
      },
      {
        "type": "Header",
        "value": "przykłady rozwiązania",
        "props": { "size": "sm" }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/7PCx3TKW/het.png"
      },
      {
        "type": "Header",
        "value": "porównanie złożoności",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "Złożoność czasowa problemu ośmiu hetmanów w najgorszym przypadku wynosi 8! = 40320 możliwych permutacji. W problemie skoczka figura ta ma 8 możliwych ruchów z każdego pola, a szachownicy jest 64, więc złożoność tego problemu wynosi 8^64. A zatem problem skoczka szachowego ma o wiele większą złożoność czasową dla najgorszego przypadku."
      }
    ]
  },
  {
    "title": "stos Łukasiewicza",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/pXGBnrLk/image.png",
        "props": { "description": "2020, 2023 poprawa, 2024" }
      },
      {
        "type": "Text",
        "value": "Tutaj masz podaną liczbę zapisaną w systemie ósemkowym i ją zamieniasz na dziesiętny."
      },
      {
        "type": "Math",
        "value": "`3246571_8 = 3*8^6 + 2*8^5 + 4*8^4 + 6*8^3 + 5*8^2 + 7*8^1 + 1*8^0 = 871801_{10}`"
      },
      {
        "type": "Text",
        "value": "Jawne użycie stosu może zapobiec jego przepełnieniu podczas wykonywania algorytmu, ponieważ pozwala na lepszą kontrolę nad zarządzaniem pamięcią i śledzeniem stanu rekursji. Przepełnienie stosu (ang. stack overflow) następuje, gdy rekurencja jest zbyt głęboka i przekracza ograniczenia pamięci stosu. Poprzez jawne użycie stosu zamiast polegania na automatycznej rekurencji, można wprowadzić pewne optymalizacje i techniki zarządzania pamięcią, które zmniejszają ryzyko przepełnienia. "
      }
    ]
  },
  {
    "title": "Fibonacci",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/ZKbWzLZD/image.png",
        "props": { "description": "2022" }
      },
      {
        "type": "Text",
        "value": "Rekursja drzewiasta to rodzaj rekurencji, w której rozwiązanie problemu wymaga rozwiązania wielu podproblemów, a każdy z tych podproblemów może rozgałęziać się dalej. Jest to typowa cecha algorytmów rekurencyjnych, gdzie podproblemy są identyczne lub podobne do oryginalnego problemu, a ich liczba rośnie wykładniczo wraz z rozmiarem problemu. <br></br>Oto jak wygląda drzewko rekurencji drzewiastej podczas obliczania liczby Fibonacciego F(6):"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/L557PjDH/image.png"
      },
      {
        "type": "Text",
        "value": "Zauważmy, że F(3), F(2), F(1) są obliczane wielokrotnie. F(3) jest obliczane trzy razy, F(2) i F(1) pięć razy. A zatem rekursja drzewiasta jest nieefektywna, bo powoduje wielokrotne obliczanie tych samych wartości, co prowadzi do ogromnej liczby zbędnych obliczeń."
      },
      {
        "type": "Text",
        "value": "W metodzie tablicowej używamy tablicy do zapamiętania wyników obliczeń podproblemów, co eliminuje potrzebę ich wielokrotnego liczenia. Dla F(6) za pomocą programowania dynamicznego, każdy wynik jest obliczany tylko raz, a kolejne wartości są dodawane do tablicy"
      }
    ]
  },
  {
    "title": "liczby Stirlinga",
    "data": [
      {
        "type": "Header",
        "value": "Wypełnij tablicę dwuwymiarową zawierające liczby Stirlinga drugiego rodzaju. Przeprowadź analizę złożoności rekursji w strukturach drzewiastych na podstawie liczb Stirlinga drugiego rodzaju. Udowodnij nieefektywność takiej rekursji. - 2016, 2018, 2020",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "Liczby Stirlinga drugiego rodzaju oznaczamy jako S(n,k) i odpowiadają na pytanie: \"Ile jest sposobów podziału zbioru o n elementach na k niepustych podzbiorów?\" Na przykład S(3, 2) = 3 co oznacza, że istnieją 3 różne sposoby podziału zbioru 3-elementowego na 2 grupy. Są to: <br></br>{1} i {2, 3}; <br></br>{1, 2} i {3}; <br></br>{1, 3} i {2}."
      },
      {
        "type": "Header",
        "value": "charakterystyczne wzory:",
        "props": { "size": "sm" }
      },
      {
        "type": "BulletPoint",
        "value": "S(n,n)=1: Istnieje tylko jeden sposób podziału n-elementowego zbioru na n grup, każda grupa zawierająca jeden element."
      },
      {
        "type": "BulletPoint",
        "value": "S(n,1)=1: Istnieje tylko jeden sposób podziału n-elementowego zbioru na 1 grupę, gdzie wszystkie n elementów są w jednej grupie."
      },
      {
        "type": "BulletPoint",
        "value": "S(n,k)=0 dla k>n: Nie da się podzielić zbioru na więcej niepustych podzbiorów niż liczba elementów w tym zbiorze."
      },
      {
        "type": "BulletPoint",
        "value": "S(0,0)=1"
      },
      {
        "type": "BulletPoint",
        "value": "S(n,k) = k⋅S(n-1, k) + S(n-1, k-1)"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/Y0BkXjsK/image.png",
        "props": {
          "description": "tablica dwuwymiarowa z liczbami Stirlinga drugiego rodzaju"
        }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/tJnZ61nK/image.png",
        "props": { "description": "drzewko liczb Stirlinga" }
      },
      {
        "type": "Text",
        "value": "Widzimy, że niektóre z tych liczb są obliczane wielokrotnie, np S(1,1), S(1,0)"
      }
    ]
  },
  {
    "title": "problem komiwojażera",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/HnBCbpbg/image.png",
        "props": { "description": "2019 poprawa" }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/9MXf78wv/image.png",
        "props": { "description": "2020" }
      },
      {
        "type": "Text",
        "value": "Problem komiwojażera polega na odnalezieniu minimalnego cyklu Hamiltona w grafie ważonym. Nazwa pochodzi od typowej ilustracji problemu, przedstawiającej go z punktu widzenia wędrownego sprzedawcy (komiwojażera): dane jest n miast, które komiwojażer ma odwiedzić, oraz odległość pomiędzy każdą parą miast. Celem jest znalezienie najkrótszej drogi łączącej wszystkie miasta, zaczynającej się i kończącej się w tym samym punkcie <br></br>Wyszukiwanie lokalne to technika, która zaczyna od jakiegoś początkowego rozwiązania (niekoniecznie optymalnego) i następnie próbuje je ulepszać, przechodząc do rozwiązań leżących w jego „sąsiedztwie” (lokalnych), aż do momentu, gdy nie można znaleźć lepszego sąsiedniego rozwiązania."
      },
      {
        "type": "Header",
        "value": "Operacje na TSP",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "<b>2-opt</b>: zamiana miejscami dwóch sąsiednich wierzchołków. <br></br>przed: 1-2-3-1 <br></br>po: 1-3-2-1 <br></br><b>3-opt</b>: zamiana miejscami dwóch wierchołków oddzielonych jednym wierzchołkiem <br></br>przed: 1-2-3-4-1 <br></br>po: 1-4-3-2-1 <br></br><b>swap</b>: uogólnienie n-opt <b>reversal</b>: zmiana kolejności pewnego zbioru wierzchołków. <br></br>przed: 1-2-3-4-5-6-1 <br></br>po: 1-5-4-3-2-6-1"
      },
      {
        "type": "Text",
        "value": "W naszym zadaniu nie mogą sąsiadować ze sobą dwa wierchołki parzyste ani nieparzyste, więc w zasadzie przyda nam się tylko 3-opt. Zauważmy, że kiedy 1 znajduje się na początku i na końcu, to zamienić się mogą ze sobą jedynie 3 i 5 a także 2, 4 i 6. Daje nam to 12 możliwych ułożeń wierchołków. Oto one:"
      },
      {
        "type": "Image",
        "value": "",
        "props": { "description": "tu będzie zdjęcie jak nie zapomnę go dodać" }
      },
      {
        "type": "Text",
        "value": "A oto rozwiązanie zadania krok po kroku:"
      },
      {
        "type": "Image",
        "value": "",
        "props": {
          "description": "tu będzie rozwiązanie jak nie zapomnę go dodać"
        }
      },
      {
        "type": "Text",
        "value": "Ja już rozpisałem sobie wcześniej możliwe kolejności odwiedzanych wierchołków, więc wiem że minimalną wagą jest 10 i kiedy otrzymam tę liczbę już nie kombinuję dalej. Problem może pojawić się przy większej liczbie wierchołków, gdzie rozpisanie tego wszystkiego zajmie więcej czasu. Tutaj już nie wiem jak pomóc."
      }
    ]
  },
  {
    "title": "10 cech dobrego kodu",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/3JYwKDfk/image.png",
        "props": { "description": "2017" }
      },
      {
        "type": "Text",
        "value": "Wzięte z wykładu:"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/DzThgVV8/zasady.png"
      }
    ]
  },
  {
    "title": "przenośność programowania",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/Sxy7zrVC/image.png",
        "props": { "description": "2017" }
      },
      {
        "type": "Text",
        "value": "Przenośność programowania oznacza zdolność aplikacji do działania na różnych platformach bez potrzeby zmiany kodu źródłowego lub z minimalnymi zmianami. "
      },
      {
        "type": "Header",
        "value": "Problemy związane z przenośnością:",
        "props": { "size": "md" }
      },
      {
        "type": "List",
        "value": [
          {
            "type": "BulletPoint",
            "value": "<b>różnice w systemach operacyjnych</b> - Program napisany dla systemu Windows może nie działać poprawnie na systemie Linux lub macOS z powodu różnic w systemach plików, API systemowych, i zarządzaniu pamięcią."
          },
          {
            "type": "BulletPoint",
            "value": "<b>różnice w architekturze sprzętowej</b> - Kod optymalizowany pod kątem architektury x86 może nie działać na architekturze ARM. Różnice w sposobie zarządzania pamięcią i rejestrami mogą powodować problemy."
          },
          {
            "type": "BulletPoint",
            "value": "<b>różnice w bibliotekach i narzędziach</b> - Aplikacja korzystająca z bibliotek specyficznych dla jednej platformy (np. biblioteki WinAPI na Windowsie) może nie być w stanie działać na innej platformie, jeśli biblioteki te nie są dostępne."
          },
          {
            "type": "BulletPoint",
            "value": "<b>problemy z różnicami w wersjach języków programowania</b> - Wersje języków programowania mogą różnić się w różnych środowiskach, co może prowadzić do niezgodności składni i semantyki, np. różnice między wersjami Javy lub Pythona."
          },
          {
            "type": "BulletPoint",
            "value": "<b>problemy z kodowaniem znaków i lokalizacją</b> - Aplikacje mogą mieć problemy z interpretacją różnych kodowań znaków (np. UTF-8 vs. ASCII) oraz z różnymi ustawieniami lokalizacji (np. format daty, waluta)."
          }
        ]
      },
      {
        "type": "Header",
        "value": "Metody zapewnienia przenośności:",
        "props": { "size": "md" }
      },
      {
        "type": "List",
        "value": [
          {
            "type": "BulletPoint",
            "value": "<b>używanie standardów i bibliotek wieloplatformowych</b> - Korzystanie z języków programowania i bibliotek, które są zgodne z międzynarodowymi standardami, takich jak POSIX (Portable Operating System Interface) dla systemów Unix lub używanie bibliotek takich jak Boost dla C++. Standardowe biblioteki zapewniają jednolite API niezależnie od platformy."
          },
          {
            "type": "BulletPoint",
            "value": "<b>kompilacja krzyżowa</b> - Używanie kompilatorów, które wspierają wiele platform (np. GCC z obsługą wielu architektur) i konfiguracja środowiska do kompilacji kodu dla różnych platform bez potrzeby zmiany kodu źródłowego."
          },
          {
            "type": "BulletPoint",
            "value": "<b>używanie maszyn wirtualnych i środowisk uruchomieniowych</b> - Korzystanie z maszyn wirtualnych takich jak Java Virtual Machine (JVM) dla Javy, .NET Common Language Runtime (CLR) dla C# lub Pythona, co pozwala na uruchamianie aplikacji w różnych środowiskach bez zmiany kodu."
          },
          {
            "type": "BulletPoint",
            "value": "<b>używanie kontenerów</b> - Stosowanie technologii kontenerów, takich jak Docker, które izolują aplikacje od środowiska systemu operacyjnego i zapewniają, że aplikacja działa tak samo niezależnie od środowiska uruchomieniowego."
          },
          {
            "type": "BulletPoint",
            "value": "<b>programowanie z myślą o przenośności</b> - Przestrzeganie najlepszych praktyk w programowaniu, takich jak unikanie funkcji i bibliotek specyficznych dla jednej platformy, testowanie aplikacji na różnych systemach operacyjnych i architekturach, oraz używanie narzędzi do automatycznego testowania przenośności (np. Continuous Integration systems)."
          }
        ]
      }
    ]
  },
  {
    "title": "matroidy",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/kGcYNR0Q/image.png",
        "props": { "description": "2017" }
      },
      {
        "type": "Text",
        "value": "Przeczytaj sb <a href='http://algorytmy.ency.pl/artykul/matroid'>ten</a> artykuł kilka razy. Ja dopiero za którymś razem zajarzyłem. <br></br><b>Matroid</b> – struktura matematyczna składająca się z niepustego zbioru elementów E i takiej rodziny jego podzbiorów I, że spełnione są następujące warunki:"
      },
      {
        "type": "List",
        "value": [
          "Jeśli jakiś zbiór należy do I, to wszystkie jego podzbiory także należą do I.",
          "Jeśli weźmiemy dowolne dwa zbiory należące do I o różnej liczbie elementów, to jesteśmy w stanie dodać do mniejszego z nich taki element z większego (spośród tych, które nie należą do mniejszego), że utworzony w ten sposób zbiór także będzie należał do I"
        ]
      },
      {
        "type": "Text",
        "value": "Właściwość idealnej podstruktury mówi, że optymalne rozwiązanie problemu można uzyskać przez optymalne rozwiązania jego podproblemów. <br></br>Zarówna algorytm Prima, jak i Kruskala korzystają z tej właściości. Ale w przypadku algorytmu Prima proces znajdowania MST jest bardziej oparty na lokalnym rozszerzaniu drzewa, a nie na łączeniu mniejszych niezależnych poddrzew, jak w przypadku algorytmu Kruskala. Tak więc to algoyrtm Kruskala korzysta bezpośrednio z własności optymalnej podstruktury."
      }
    ]
  }
]
