[
  {
    "title": "metoda LCG",
    "data": [
      {
        "type": "Text",
        "value": "Linear congruence generator działa w oparciu o poniższy wzór:"
      },
      {
        "type": "Math",
        "value": "`X_n=(a*X_{n-1}+c)mod m`"
      },
      {
        "type": "Text",
        "value": "Gdzie: <br></br>a - mnożnik <br></br> X<sub>0</sub> - ziarno <br></br> c - krok/dodatek/przesunięcie/przyrost <br></br> m - moduł"
      },
      {
        "type": "Header",
        "value": "Wartości parametrów",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "Najważniejsze to żeby m było większe od zera, zaś a, c, X0 większe lub równe zero i mniejsze od m (choć czasami widuję zapis że a nie może być równe 0 i może być większe od m więc już sam nie wiem). I taki generator by już zadziałał, ale istnieje ryzyko, że okres byłby mały. Dlatego trzeba lepiej zadbać o parametry."
      },
      {
        "type": "ListElement",
        "value": "moduł m w prawdziwych generatorach to zazwyczaj duża potęga dwójki, np. 2^32, ale gdybyś miał rozpisać na kartce, to możesz wybrać dowolną liczbę, np. 30"
      },
      {
        "type": "ListElement",
        "value": "c powinno być względnie pierwsze z m, czyli ich największy wspólny dzielnik to 1"
      },
      {
        "type": "BulletPoint",
        "value": "jeśli chodzi o mnożnik a, to tutaj jest kilka sposobów, ale najprostszym jest takie dobranie jego wartości, żeby b=a-1 było względnie pierwsze z dzielnikami modułu/ podzielne przez wszystkie czynniki pierwsze m"
      },
      {
        "type": "BulletPoint",
        "value": "ziarno dobierasz jak chcesz"
      },
      {
        "type": "Header",
        "value": "Przykład",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "Niech m będzie równe 18, zaś X<sub>0</sub>=7. <br></br>Czynniki modułu to 1, 2, 3, 6, 9, 18 z czego liczbami pierwszymi są tylko 2 i 3. Liczba b, która jest podzielna przez zarówno 2 i 3 to na przykład 6. 6 = a - 1 => a = 7. <br></br>C musi być względnie pierwsze z 18, niech będzie to 5. <br></br>Wygenerowany w ten sposób ciąg liczb losowych wygląda tak: 0, 5, 4, 15, 2, 1, 12, 17, 16, 9, 14, 13, 6, 11, 10, 3, 8, 7. "
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "Pytanie co zrobić jeśli moduł jest liczbą pierwszą. To masz wtedy problem XD. Niektórzy po prostu dają a o 1 większe od m, ale nie wiem czy to przejdzie u Kokosa, bo niby nas uczą, że a nie może być większe od m. Tutaj musisz wyznaczyć mnożnik inną metodą. Rozpatrujemy wszystkich kandydatów a z zakresu [2, m) i dla każdego z nich wyznaczamy λ takie, że spełnione jest równanie:"
      },
      {
        "type": "Math",
        "value": "`a^λ mod m = 1`"
      },
      {
        "type": "Text",
        "value": "Na przykład dla m = 13:<br></br>a=2 → λ=12<br></br>a=3 → λ=3<br></br>a=4 → λ=6<br></br>a=5 → λ=4<br></br>a=6 → λ=12<br></br>a=7 → λ=12<br></br>a=8 → λ=4<br></br>a=9 → λ=3<br></br>a=10 → λ=6<br></br>a=11 → λ=12<br></br>a=12 → λ=2 <br></br>Ze wszystkich uzyskanych wyników wybieramy tylko te, dla których lambda jest największa:W naszym przypadku będą to 3 wyniki:<br></br>a=6 → λ=12<br></br>a=7 → λ=12<br></br>a=11 → λ=12 <br></br>I znich wybieramy największe a, czyli 11."
      },
      {
        "type": "Code",
        "value": "m = 13  # moduł\nx0 = 8  # ziarno\na = 11  # mnożnik\nc = 5  # dodatek\n\n\nfor i in range(m): \n    if i == 0:\n        x = (a * x0 + c) % m\n        print(x)\n        prev_x = x\n    else:\n        x = (a * prev_x + c) % m\n        print(x)\n        prev_x = x\n        \n# output: 2, 1, 3, 12, 7, 4, 10, 11, 9, 0, 5, 8, 2",
        "props": { "language": "python" }
      },
      {
        "type": "Header",
        "value": "Na co wpływają parametry?",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "<b>Moduł</b> wpływa na największą możliwą liczbę. m = X<sub>max</sub> + 1 zatem X<sub>max</sub> = m -1. Nie znaczy to że w wygenerowanym ciągu zawsze ona wystąpi. <br></br><b>Ziarno</b> wpływa na miejsce w pierścieniu liczb pseudolosowych, od którego rozpocznie się generacja następnych liczb. Gdyby w pierwszym przykładzie zamiast 7 użyć ziarna 8, to ciąg wyglądałby: 7, 0, 5, 4, 15, 2, 1, 12, 17, 16, 9, 14, 13, 6, 11, 10, 3, 8 czyli byłby przesunięty o jedną liczbę. <br></br><b>Mnożnik a</b> jest używany do skalowania poprzedniej wartości pseudolosowej, co pomaga w rozpraszaniu wartości i tworzeniu bardziej złożonych wzorców w generowanej sekwencji liczb. <br></br><b>Dodatek c</b> jest używany do przesunięcia poprzedniej wartości w generowanej sekwencji, co pomaga w unikaniu pewnych cykli i wzorców, które mogą powstać przy zastosowaniu samego mnożnika."
      },
      {
        "type": "Header",
        "value": "Zadania",
        "props": { "size": "md" }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/Mp83nNTt/image.png",
        "props": { "description": "2023 poprawa" }
      },
      {
        "type": "Text",
        "value": "Moim zdaniem najłatwiej będzie najpierw wygenerować liczby z zakresu <0, 11> a potem pododawać do nich 1. Moduł m = X<sub>max</sub> + 1 = 11 + 1 = 12. Wtedy mnożnik a = 7. Niech ziarno = 8, dodaktek c = 5. Otrzymamy wtedy tablicę liczb: [1, 0, 5, 4, 9, 8]. Jak stworzymy drugą tablicę i do każdego elementu dodamy 1, otrzymamy: [2, 1, 6, 5, 10, 9]. Uwaga: dodanie 1 bezpośrednio we wzorze nie zadziała - sprawdzałem."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/vm84Z8dy/image.png",
        "props": { "description": "?" }
      },
      {
        "type": "Text",
        "value": "Generujemy normalnie liczby, a potem je skalujemy dzieląc przez m. Wtedy otrzymamy liczby z zakresu [0, 1). Tak jak powyżej, trzeba stworzyć dwie tablice, bo dzielenie bezpośrednio we wzorze nie zadziała. Jeśli chcemy ułamki z przedziału [min, max) to wzór będzie wyglądał tak:"
      },
      {
        "type": "Math",
        "value": "`min + ((X_n/m)(max - min))`"
      },
      {
        "type": "Header",
        "value": "zastosowania LCG do generowania liczb ułamkowych",
        "props": { "size": "sm" }
      },
      {
        "type": "BulletPoint",
        "value": "<b>Symulacje komputerowe</b>: Generowanie liczb ułamkowych jest istotne w symulacjach, które wymagają losowych zmiennych ciągłych w określonych zakresach, np. symulacje Monte Carlo"
      },
      {
        "type": "BulletPoint",
        "value": "<b>Gry komputerowe</b>: W grach liczby ułamkowe mogą być używane do generowania losowych pozycji, prędkości, czy innych parametrów fizycznych."
      },
      {
        "type": "BulletPoint",
        "value": "<b>Grafika komputerowa</b>: W grafice komputerowej generowanie losowych liczb w przedziałach jest używane do takich celów jak teksturowanie, generowanie szumów, czy algorytmy losowego rozmieszczenia."
      },
      {
        "type": "Header",
        "value": "ograniczenia",
        "props": { "size": "sm" }
      },
      {
        "type": "BulletPoint",
        "value": "<b>Krótkie okresy</b>: LCG mogą mieć stosunkowo krótkie okresy, co oznacza, że sekwencje liczb mogą się powtarzać. Okres LCG jest ograniczony przez moduł m, ale może być znacznie krótszy w praktyce, szczególnie jeśli parametry a i c nie są dobrze dobrane."
      },
      {
        "type": "BulletPoint",
        "value": "<b>Jakość losowości</b>: LCG mogą mieć problemy z równomiernością rozkładu liczb pseudolosowych, co może prowadzić do zauważalnych wzorców, jeśli parametry nie są odpowiednio dobrane."
      },
      {
        "type": "BulletPoint",
        "value": "<b>Deterministyczność</b>: LCG są deterministyczne, co oznacza, że dla danego ziarna generują tę samą sekwencję liczb. Może to być niekorzystne w aplikacjach wymagających wysokiej jakości losowości."
      },
      {
        "type": "Text",
        "value": "Powyższe punkty tyczą się generowania wsystkich liczb, nie tylko ułamkowych, ale przecież ułamki też są liczbami, więc powinno przejść."
      }
    ]
  },
  {
    "title": "metoda ACG",
    "data": [
      {
        "type": "Text",
        "value": "Czyli addytywny generator. "
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/kXMJZhsB/image.png"
      },
      {
        "type": "Text",
        "value": "Jak coś to podsyłam pdf gdzie jest on omówiony, może coś z tego więcej zrouzmiesz niż ja. <a href='https://pdfhost.io/v/xX6kCoJz1_Addytywna_metoda_kongruencyjna_wyjasnienie_zasad'>LINK</a>"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/Fz65tZg8/image.png",
        "props": { "description": "2023" }
      },
      {
        "type": "Text",
        "value": "Tworzymy nową tablicę Y, której elementy są takie same jak tablicy X, ale są ustawione w odwrotnej kolejności. Y = [3, 4, 7, 1, 5, 2]. Stosujemy wzór:"
      },
      {
        "type": "Math",
        "value": "`Y[k] = (Y[j] + Y[k])mod m`"
      },
      {
        "type": "Text",
        "value": "Potem zmniejszamy j oraz k o 1. Ważne jest, że tablica Y jest numerowana od 1, a nie od 0. A zatem j oraz k nie mogą przyjąć wartości 0. Zamiast tego przyjmują wartość n czyli rozmiar tablicy."
      },
      {
        "type": "Header",
        "value": "krok 1",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`Y[5] = (Y[2] + Y[5])mod m = (4+5)mod 8 = 1`"
      },
      {
        "type": "Text",
        "value": "nowa tablica: Y=[3, 4, 7, 1, 1, 2]; j=1; k=4"
      },
      {
        "type": "Header",
        "value": "krok 2",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`Y[4] = (Y[1] + Y[4])mod m = (3+1)mod 8 = 4`"
      },
      {
        "type": "Text",
        "value": "nowa tablica: Y=[3, 4, 7, 4, 1, 2]; j=6; k=3"
      },
      {
        "type": "Header",
        "value": "krok 3",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`Y[3] = (Y[6] + Y[3])mod m = (2+7)mod 8 = 1`"
      },
      {
        "type": "Text",
        "value": "nowa tablica: Y=[3, 4, 1, 4, 1, 2]; j=5; k=2"
      },
      {
        "type": "Header",
        "value": "krok 4",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`Y[2] = (Y[5] + Y[2])mod m = (1+4)mod 8 = 5`"
      },
      {
        "type": "Text",
        "value": "nowa tablica: Y=[3, 5, 1, 4, 1, 2]; j=4; k=1"
      },
      {
        "type": "Header",
        "value": "krok 5",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`Y[1] = (Y[4] + Y[1])mod m = (4+3)mod 8 = 7`"
      },
      {
        "type": "Text",
        "value": "nowa tablica: Y=[7, 5, 1, 4, 1, 2]; j=3; k=6"
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "5 pierwszych liczb generowanych w wyniku zastosowania ACG to: 1, 4, 1, 5, 7. Tablica Y po pięciu krokach wygląda tak: [7, 5, 1, 4, 1, 2]"
      }
    ]
  }
]
