[
  {
    "title": "wiadomości wstępne",
    "data": [
      {
        "type": "Text",
        "value": "<b>Złożoność obliczeniowa</b> wyznacza wielkość zasobów jakie potrzebne są do wykonania algorytmu w dowolnym systemie komputerowym. Wyróżniamy jej rodzaje:<br></br> <b>Złożoność czasowa</b> - zależność miedzy rozmiarem i porządkiem danych wejściowych algorytmu, a czasem wykonania algorytmu.<br></br><b>Złożoność pamięciowa</b> zależność pomiędzy rozmiarem i porządkiem danych wejściowych algorytmu, a jego zapotrzebowaniem na pamięć niezbędną do jego realizacji.<br></br>Aby oszacować złożoność obliczeniową używamy notacji asymptotycznych. Oznaczane są one greckimi literami:"
      },
      {
        "type": "List",
        "value": [
          {
            "type": "ListElement",
            "value": "O (omikron) - asymptotyczna granica górna, pesymistyczny przypadek"
          },
          {
            "type": "ListElement",
            "value": "Θ (theta) - asymptotycznie dokładne oszacowanie, przypadek średni"
          },
          {
            "type": "ListElement",
            "value": "Ω (omega) - asymptotyczna granica dolna, optymistyczny przypadek"
          }
        ]
      },
      {
        "type": "Text",
        "value": "Wyróżniamy następujące klasy złożoności obliczeniowej:"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/BbfQx9g5/image.png"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/htMCh7c2/image.png",
        "props": {
          "description": "porównanie złożoności różnych algorytmów sortowania"
        }
      }
    ]
  },
  {
    "title": "tempo wzrostu funkcji",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/gkd2jprm/image.png",
        "props": {
          "description": "2023 egz. poprawkowy",
          "orientation": "horizontal"
        }
      },
      {
        "type": "Math",
        "value": "Odpowiedź:  `1 < log_2 n < n < nlog_2 n < n^2 < n^2log_2 n < n^3 < 2^n < n!`"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/6pYXw3SX/image.png",
        "props": { "description": "2016" }
      },
      {
        "type": "Math",
        "value": "`1 < log(logn) < (logn)^2 < n^(1/2) < n < n^10 < 2^n < n! < n^n`"
      },
      {
        "type": "Text",
        "value": "Równość O()=Ω() oznacza, że górne i dolne oszacowanie sa takie same(?) Nic innego mi nie przychodzi do głowy."
      },
      {
        "type": "Comment",
        "value": "sprawdzić n! i n^n oraz dokończyć zadanie"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/zvk5KL35/image.png",
        "props": { "description": "2023", "orientation": "horizontal" }
      },
      {
        "type": "Math",
        "value": "Odpowiedź: `log_2 n^4 < sqrt(n) < 3^n < 2^(2n) < n!`"
      },
      {
        "type": "Text",
        "value": "Rząd funkcji będącej sumą innych funkcji jest zawsze równy rzędowi najszybciej rosnącej funkcji, czyli w naszym przypadku n!. To dlatego, że w miarę zbliżania się n do nieskończoności pozostałe funkcje przestają mieć znaczenie w porównaniu z najszybciej rosnacą. <br></br><i>Jeżeli f(n) jest wielomianem i g(n) można oszacować z góry przez funkcję wykładniczą h(n), to f(n) + g(n) można oszacować z dołu przez funkcję wykładniczą h(n).</i><br></br>Jeśli nie wiesz, która funkcja rośnie szybciej, a która wolniej, możesz je porównać wykorzystując regułę de l`Hopitala, tylko trzeba znać wzory na pochodne:"
      },
      {
        "type": "YouTube",
        "value": "sm0BB_3qMlI"
      }
    ]
  },
  {
    "title": "czas wykonywania algorytmu",
    "data": [
      {
        "type": "Text",
        "value": "Jaki jest max rozmiar <i>n</i> problemu, który można rozwiązać w tym samym czasie na komputerze 10 razy szybszym? Załóżmy, że złożoność algorytmu jest liniowa. Oznaczmy <i>n</i> jako liczbę danych wejściowych na wolnoejszym komputerze, a <i>s</i> jako szukaną liczbę danych wejściowych na szybszym komputerze.  Wtedy:"
      },
      {
        "type": "Math",
        "value": "`n=s/10 => s=10n`",
        "props": { "fontSize": 15 } 
      },
      {
        "type": "Text",
        "value": "Z tego wynika, że na 10x szybszym komputerze maksymalny rozmiar problemu, który można rozwiązać w tym samym czasie wynosi 10n"
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "Rozważmy teraz algorytm o złożoności kwadratowej:"
      },
      {
        "type": "Math",
        "value": "`n^2=(s^2)/10 => s^2=10n^2 => s=sqrt(10)n`"
      },
      {
        "type": "Text",
        "value": "Przykładowo mamy tablicę n elementów i musimy ją posortować bubble sortem, którego złożoność czasowa jest kwadratowa. Na komputerze 10 razy szybszym w tym samym czasie można posortować tablicę o rozmiatrze √10*n czyli około 3,16 razy większą."
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "Dla złożoności n^3:"
      },
      {
        "type": "Math",
        "value": "`n^3=(s^3)/10 => s^3=10n^3 => s=root(3)(10)n`"
      },

      {
        "type": "Text",
        "value": "Uogólniając, dla funkcji wielomianowej n^w na komputerze t razy szybszym wynik będzie wynosił:"
      },
      {
        "type": "Math",
        "value": "`s=root(w)(t)*n`",
        "props": { "fontSize": 20}
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "Teraz coś trudniejszego. Rozpatrzmy funkcję wykładniczą <i>2^n</i>. Jaki jest max rozmiar <i>n</i> problemu, który można rozwiązać w tym samym czasie na komputerze <i>t</i> razy szybszym?"
      },
      {
        "type": "Math",
        "value": "`2^n=(2^s)/t => 2^s=t*2^n`"
      },
      {
        "type": "Text",
        "value": "Znając pewne wzory dla logarytmów możemy zapisać:"
      },
      {
        "type": "Math",
        "value": "`2^s=2^(log_2 t)*2^(n)=2^(log_2 t + n)`"
      },
      {
        "type": "Text",
        "value": "Podstawy są takie same, więc porównujemy wykładniki:"
      },
      {
        "type": "Math",
        "value": "`s=log_2 t + n`",
        "props": { "fontSize": 20 } 
      },
      {
        "type": "Text",
        "value": "Odpowiedź: na komputerze <i>t</i> razy szybszym można rozwiązać problem o rozmiarze lg(t) + n w tym samym czasie co na komputzerze wolniejszym dla danych o rozmiarze <i>n</i>"
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "Teraz dla funkcji logarytmicznej:"
      },
      {
        "type": "Math",
        "value": "`log_2 n = (log_2 s)/t => t*log_2 n = log_2 s => log_2 n^t = s`"
      },
      {
        "type": "Text",
        "value": "Podstawa logarytmu jest taka sama, więc:"
      },
      {
        "type": "Math",
        "value": "`s=n^t`",
        "props": { "fontSize": 20, "height": 20  } 
      },
      {
        "type": "Text",
        "value": "Mam nadzieję że było zrozumiałe, jak nie to sory, starałem się. Na koniec tego segmentu przedstawiam dwa przydatne wzory z logarytmami, jakby ktoś zapomniał ze szkoły."
      },
      {
        "type": "Math",
        "value": "`a^(log_a b) = b`",
        "props":{"height": 40 } 
      }, 
      {
        "type": "Math",
        "value": "`a*log_b c = log_b c^a` ",
        "props": { "height": 40  }
      }
    ]
  },
  {
    "title": "reszta zadań",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/HLHLcC6Q/image.png",
        "props": { "description": "2023, 2024" }
      },
      {
        "type": "Text",
        "value": "<b>A)</b><br></br>n^2 = 10^2 = 100 => 5 sekund <br></br>n<sub>2</sub>^2 = 15^2 = 225 => x sekund <br></br>mnożąc na krzyż: 255*5 = 100*x => x = 12,75 s."
      },
      {
        "type": "Text",
        "value": "<b>B)</b><br></br> n^2 = 10^2 = 100 => 5 sekund <br></br>n<sub>x</sub>^2 => 20 sekund <br></br>mnożąc na krzyż: 5n<sub>x</sub>^2 = 2000 sekund <br></br>n<sub>x</sub>^2 = 400 <br></br>n<sub>x</sub>=20"
      },
      {
        "type": "Text",
        "value": "<b>C)</b><br></br>Najpierw policzmy ile czasu zajmie to na wolniejszym komputerze K, a potem wynik podzielmy przez 256.<br></br>n^2 = 10^2 = 100 => 5 sekund <br></br>n<sub>2</sub>^2 = 8^2 = 64 => x sekund <br></br>x = 5*64/100 = 3,2 sekundy.<br></br>Zatem odpowiedź to 3,2/256 ≈ 0,0125 s."
      },
      {
        "type": "Divider"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/kgysdVsy/image.png",
        "props": { "description": "2017" }
      },
      {
        "type": "Divider"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/j5D4NMb8/image.png",
        "props": { "description": "2019" }
      }
    ]
  }
]
