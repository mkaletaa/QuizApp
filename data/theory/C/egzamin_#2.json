[
  {
    "title": "",
    "data": [
      {
        "type": "Text",
        "value": "<b>34.</b> Jaki jest cel stosowania przyrostka volatile? O czym informuje on kompilator?<br></br>informuje, że zawsze musi sięgać do pamięci, aby odczytaćwartość zmiennej <br></br>informuje kompilator, że zmienna może zmieniać swoją wartość bez jego wiedzy."
      },
      {
        "type": "Text",
        "value": "<b>35.</b> Jak długo żyje obiekt stworzony operatorem new? <br></br>do końca działania programu <br></br>do momentu wywołania operatora delete"
      },
      {
        "type": "Text",
        "value": "<b>36.</b> Jaka jest ochrona przed przekazaniem limitu typu całkowitego?<br></br>Nie będzie żadnego ostrzeżenia, zmienna przyjmie wartość ujemną"
      },
      {
        "type": "Text",
        "value": "<b>37.</b> Jaka jest różnica między zmienną zadeklarowaną przed instrukcją for, a zmienną zdefiniowaną w wyrażeniu inicjalizacyjnym pętle for?<br></br>zmienna zdefiniowana przed pętlą jest dostępna zarówno wewnątrz pętli jak i poza nią <br></br>zmienna zdefiniowana w wyrażeniu inicjalizującym pętle for jest dostępna tylko w pętli"
      },
      {
        "type": "Text",
        "value": "<b>38.</b> Gdzie funkcja tworzy obiekty lokalne?<br></br>na stosie"
      },
      {
        "type": "Text",
        "value": "<b>41.</b> Co zrobić, aby funkcja mogła modyfikować obiekty przesłane do niej jako argumenty?<br></br>przesłać argumenty przez referencje albo adres"
      },
      {
        "type": "Text",
        "value": "<b>42.</b> Jaka jest różnica między pętlą while, a do...while()?<br></br>do...while wykonuje się zawsze przynajmniej raz.<br></br>w do...while najpierw wykonują się instrukcje, potem sprawdzany jest warunek, w while odwrotnie."
      },
      {
        "type": "Text",
        "value": "<b>43.</b> jaka instrukcja pozwala na przerwanie aktualnie wykonywanej pętli i przejście do kolejnego obiegu?<br></br>continue"
      },
      {
        "type": "Text",
        "value": "<b>44.</b> Jaką wartość zwróci funkcja: auto f()->int {return 4,2}?<br></br>2"
      },
      {
        "type": "Text",
        "value": "<b>45.</b> Czy konstruktor domniemany może mieć argumenty domniemane?<br></br>tak"
      },
      {
        "type": "Text",
        "value": "<b>46.</b> Co to polimorfizm? <br></br>mechanizm korzystający z późnego wiązania metody"
      },
      {
        "type": "Text",
        "value": "<b>47.</b> Czy mając stały obiekt klasy K można do niego wywołać funkcję składową const?<br></br>tak"
      },
      {
        "type": "Text",
        "value": "<b>48.</b> Co jest potrzebne, aby z zakresu klasy pochodnej dostać się do składników prywatncyh klasy podstawowej?<br></br>publiczne funkcje składowe pracujące na prywatnych składnikach klasy bazowej <br></br>chronione funkcje składowe pracujące na prywatnych składnikach klasy bazowej"
      },
      {
        "type": "Text",
        "value": "<b>49.</b> Czy może istnieć klasa, w której wszystkie konstruktory są prywatne?<br></br>tak"
      },
      {
        "type": "Text",
        "value": "<b>50.</b> Co to jest destruktor?<br></br>Specjalna funkcja klasy, która sprząta po obiekcie (zwalnia pamięć)<br></br>specjalna funkcja składowa wywoływana automatycznie w momencie likwidacji obiektu."
      },
      {
        "type": "Text",
        "value": "<b>51.</b> Co to jest wiązanie?<br></br>Przypisanie wywołania funkcji w momencie kompilacji na podstawie tego obiektu"
      },
      {
        "type": "Text",
        "value": "<b>52.</b> Zdania prawdziwe o klasie:<br></br>Składnikiem klasy może być oniekt innej klasy <br></br>składnikiem klasy może być obiekt typu double <br></br>składnikiem klasy może być funkcja <br></br>klasa to typ"
      },
      {
        "type": "Text",
        "value": "<b>53.</b> Które funkcje są dziedziczone?<br></br>konstruktor <br></br>konstruktor kopiujący <br></br>destruktor <br></br>destruktor kopiujący"
      },
      {
        "type": "Text",
        "value": "<b>54.</b> W przypadku przeładowania operatorów: <br></br>operatory strumienia wejścia (>>) i wyjścia (<<) mogą być zdefiniowane jako składnik klasy lub jako funkcja globalna <br></br>Jeśli operator przypisania nie jest zdefiniowany, kompilator zdefiniuje go automatycznie"
      },
      {
        "type": "Text",
        "value": "<b>55.</b> Definicja TCordinate& operator++(int); jest przeładowaniem operatora:<br></br>post inkrementacji <br></br>jeszcze było takie z void zamiast int, to też jest postinkrementacja (chyba)"
      },
      {
        "type": "Text",
        "value": "<b>56.</b> Proces zamknięcia pewnych danych klasowych oraz funkcji tak, że są one dostępne tylko dla funkcji danej klasy i funkcji zaprzyjaźnionych to:<br></br>enkapsulacja"
      },
      {
        "type": "Text",
        "value": "<b>57.</b> Co to jest unia?<br></br>struktura danych umożliwiająca przechowywanie obiektu danego typu."
      },
      {
        "type": "Text",
        "value": "<b>58.</b> Funkcja składowa jest typu inline jeżeli...<br></br>Jest umieszczona w obrębie zdefiniowanej klasy lub poza nią jeśli jest to wyrażone słowem inline"
      },
      {
        "type": "Text",
        "value": "<b>59.</b> Z czego wynika rozmiar unii? <br></br>Z rozmiaru jej największego obiektu."
      },
      {
        "type": "Text",
        "value": "<b>61.</b> Wybierz poprawną definicję operatora []:<br></br>wszystkie definicje są błędne"
      },
      {
        "type": "Text",
        "value": "<b>62.</b> Definicja klasy:<br></br>nie jest definicją jeszcze żadnych obiektów, więc w pamięci nie istnieje jeszcze żaden obiekt."
      },
      {
        "type": "Text",
        "value": "<b>63.</b> Jak wywołać funkcję składową fun klasy K, jeśli jeszcze nie ma ani jednego obiektu?<br></br>poprzez  nazwę klasy: K::fun();"
      },
      {
        "type": "Text",
        "value": "<b>64.</b> W przypadku wskaźnika this: <br></br>odnosi się do aktualnie używanego obiektu <br></br>może być użyty tylko z wnętrza niestatycznych funkcji składowych"
      },
      {
        "type": "Text",
        "value": "<b>65.</b> jaka jest kolejność tworzenia obiektów?<br></br>obiekt klasy bazowej -> obiekt klasy pochodnej -> obiekty klas zawierających się w klasie pochodnej"
      },
      {
        "type": "Text",
        "value": "<b>66.</b> Czy na liście inicjalizacyjnej można wykonać jakąś funkcję?<br></br>tak"
      },
      {
        "type": "Text",
        "value": "<b>67.</b> Poprawna definicja wskaźnika o nazwie p do pokazywania we wnętrzu klasy M na składniki będące wskaźnikami do obiektów typu double to:<br></br>double* M::p;"
      },
      {
        "type": "Text",
        "value": "<b>68.</b> Co to jest enkapsulacja? <br></br>Zamykanie danych 'w pudełku'; określenie, które dane mogą być dostępne na zewnątrz, a które nie"
      },
      {
        "type": "Text",
        "value": "<b>69.</b> Wybierz opcje, które dotycza konstruktora:<br></br>nie można go przesłaniać"
      },
      {
        "type": "Text",
        "value": "<b>70.</b> Co wywołuje wyrażenie: TCoordinate a=b <br></br>konstruktor kopiujący"
      },
      {
        "type": "Text",
        "value": "<b>71.</b> Zaznacz poprawną definicję obiektu klasy <br></br>Rectangle r{}<br></br>rectangle *r = new Rectangle();<br></br>Rectangle *r {new Rectangle()}"
      },
      {
        "type": "Text",
        "value": "<b>72.</b> Na czym polega późne wiązanie?<br></br>przypisanie wywołania funkcji w momencie kompilacji na podstawie typu obiektu"
      },
      {
        "type": "Text",
        "value": "<b>73.</b> W klasie K jest składnik typu const. Czy można go inicjalizować w ciele jej konstruktora?<br></br>nie"
      },
      {
        "type": "Text",
        "value": "<b>74.</b> Których operatorów nie można przeładować?"
      },
      {
        "type": "List",
        "value": [
          {
            "type": "ListElement",
            "value": "?:"
          },
          {
            "type": "ListElement",
            "value": "::"
          },
          {
            "type": "ListElement",
            "value": "*"
          },
          {
            "type": "ListElement",
            "value": "."
          }
        ]
      },
      {
        "type": "Text",
        "value": "<b>75.</b> Jeśli klasa W jest zagnieżdżona w klasie A, gdzie można umieścić definicję funkcji składowej klasy zagnieżdżonej W?<br></br>chuj wie"
      },
      {
        "type": "Text",
        "value": "<b>76.</b> Klasa K ma trzy konstruktory, ale żaden nie jest domniemany. Czy kompilator wygeneruje automatycznie konstruktor domniemany dla tej klasy?<br></br>nie"
      },
      {
        "type": "Text",
        "value": "<b>77.</b> Co wyświetli się w konsoli po uruchomieniu poniższego programu?"
      },
      {
        "type": "Code",
        "value": "#include <iostream>\nusing namespace std;\n\nclass A{\n   int x;\n};\n\nclass B : public A{\n   public:\n   void show() {\n      x=10;\n      cout << x;\n   }\n};\n\nint main(){\n   B b;\n   b.show();\n   return 0;\n}",
        "props": { "language": "cpp" }
      },
      {
        "type": "Text",
        "value": "error <br></br> <b>78.</b> jakiego dostępu jest składnik dana1:"
      },
      {
        "type": "Code",
        "value": "class Klasa{\n\t\tint dana1;\n\tpublic:\n\t\tint dana2;\n}",
        "props": { "language": "cpp" }
      },
      {
        "type": "Text",
        "value": "przez domniemanie - private"
      },
      {
        "type": "Text",
        "value": "<b>79.</b> Składniki deklarowane za etykietą private mogą zostać wykorzysatne przez:<br></br>funkcje składowe klasy <br></br>funkcje zaprzyjaźnione"
      },
      {
        "type": "Text",
        "value": "<b>80.</b> Czy wszystkie składniki klasy bazowej są dziedziczone przez klase pochodną?<br></br>tak"
      },
      {
        "type": "Text",
        "value": "<b>81.</b> Co to jest konstruktor?<br></br>funkcja składowa wywoływana autmoatycznie w momencie tworzenia obiektu <br></br>specjalna funkcja składowa klasy, która tworzy nowy obiekt."
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "W klasie K jeden ze składników-danych ma przydomek mutable.  Jeśli stworzymy stały obiekt tej klasy, na co pozwoli nam  ten przydomek mutable? <br></br> Odp: Możemy dokonywać zmian tego składnika nawet z ciała  funkcji const. "
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "Jaki operator jest używany do dziedziczenia po wielu klasach na raz? <br></br>Odp: przecinek"
      }
    ]
  }
]
