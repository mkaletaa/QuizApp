[
  {
    "title": "Optional properties and chaining",
    "data": [
      {
        "type": "Text",
        "value": "In TypeScript, you can make object properties optional using the <ins>?</ins> syntax. This means the property may or may not be present on the object."
      },
      {
        "type": "Code",
        "value": "type Car = {\n  make: string\n  model?: string\n  year: number\n  color?: string\n}\n\nconst classicCar: Car = {\n  make: 'Volkswagen',\n  year: 1970,\n  // 'model' and 'color' are optional, so this object is valid without them\n}",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "The optional chaining operator <ins>(?.)</ins> allows you to safely access deeply nested object properties without having to manually check if each property in the chain exists. If a property is <ins>null</ins> or <ins>undefined</ins>, it will return <ins>undefined</ins> instead of throwing an error."
      },
      {
        "type": "Code",
        "value": "const user = { name: 'John', address: { city: 'New York' } }\nconst city = user?.address?.city\n// If 'address' or 'city' is undefined, 'city' will be undefined, but no error will occur",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "This operator is especially useful for working with complex data structures or APIs where not all properties are guaranteed to be defined."
      }
    ]
  },
  {
    "title": "Literal types",
    "data": [
      {
        "type": "Text",
        "value": "TypeScript allows you to define literal types by setting a type equal to a specific value. This restricts the type to that exact value, making it useful for constants or cases where you expect a very specific type."
      },
      {
        "type": "Code",
        "value": "type Color = 'red' | 'green' | 'blue'\nconst color: Color = 'green'\nconst anotherColor: Color = 'yellow' //Type '\"yellow\"' is not assignable to type 'Color'.",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "You can use template literal types to build types dynamically by combining string literals."
      },
      {
        "type": "Code",
        "value": "type Color = 'red' | 'green' | 'blue'\ntype Shade = 'light' | 'dark'\n\ntype ColorShade = `${Shade}-${Color}` // Creates types like 'light-red', 'dark-green'\n\nconst colorShade: ColorShade = 'light-blue'",
        "props": { "language": "typescript" }
      }
    ]
  },
  {
    "title": "Casting",
    "data": [
      {
        "type": "Text",
        "value": "TypeScript casting (or type assertions) allows you to explicitly tell the TypeScript compiler that you know the type of a value better than it does. This is useful when TypeScript's type inference system can't deduce the correct type, or when you're working with more complex scenarios where you need to override the inferred types. There are two syntaxes available:"
      },
      {
        "type": "Code",
        "value": "{ //angle-bracket syntax\n  let value: any = 'Hello, TypeScript'\n  let strLength: number = (<string>value).length\n} //Here, <string> tells TypeScript to treat the `value` variable as a string.\n\n{ // as syntax\n  let value: any = 'Hello, TypeScript'\n  let strLength: number = (value as string).length\n} //Generally preferred syntax, especially in JSX (React) files, where angle brackets may cause conflicts.",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "Casting is helpful when working with union types and you know more specific details than the compiler."
      },
      {
        "type": "Code",
        "value": "function displayLength(value: string | number) {\n  if ((value as string).length !== undefined) {\n    console.log((value as string).length)\n  } else {\n    console.log(value.toString().length)\n  }\n}\n\ndisplayLength(123) // Output: 3",
        "props": { "language": "typescript" }
      },
      {
        "type": "Header",
        "value": "Important notes:",
        "props": { "size": "sm" }
      },
      {
        "type": "List",
        "value": [
          "<u>No actual casting happens at runtime</u>: Casting in TypeScript only affects the type system at compile-time; it doesn't change the runtime behavior.",
          "<u>Unsafe casting</u>: Be cautious, as TypeScript trusts your assertions, even if they're incorrect.",
          "<u>Type guarding alternative</u>: Instead of casting, TypeScript provides type guards (like typeof, instanceof, or custom type predicates) to check types in a safer way."
        ]
      }
    ]
  },
  {
    "title": "`as const`",
    "data": [
      {
        "type": "Text",
        "value": "<ins>as const</ins> is used to create literal types from an object or array. By default, TypeScript treats object properties or array elements as mutable and assigns broader types. Using <ins>as const</ins> makes the values readonly and narrows the type to the most specific literal values."
      },
      {
        "type": "Code",
        "value": "const colors = ['red', 'green', 'blue'] as const\ncolors.push('yellow') //Property 'push' does not exist on type 'readonly [\"red\", \"green\", \"blue\"]'.",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "If you don't know why <ins>const</ins> at the beginning isn't enough to prevent modifying arrays (and other complex data structures), visit the introduction of \"Data types\" chapter."
      }
    ]
  },
  {
    "title": "`typeof`",
    "data": [
      {
        "type": "Text",
        "value": "In TypeScript, <ins>typeof</ins> is used to refer to the type of a variable or object. It's useful when you want to create types dynamically based on the value of a variable, without needing to manually specify the type."
      },
      {
        "type": "Code",
        "value": "// Define an object\nconst car = {\n  make: 'Toyota',\n  year: 2020,\n}\n// Use `typeof` to create a type based on the existing object\ntype CarType = typeof car // { make: string, year: number }\n// Create a new object based on the dynamically generated type\nconst myCar: CarType = {\n  make: 'Honda',\n  year: 2021,\n}\n// Error - The new object must include all properties from the original type\nconst brokenCar: CarType = {\n  make: 'Ford',\n  // Missing 'year'\n}",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "If <ins>as const</ins> is applied, <ins>typeof</ins> infers a literal type."
      },
      {
        "type": "Code",
        "value": "const car = {\n  make: 'Toyota',\n  year: 2020,\n} as const\n\ntype CarType = typeof car // { make: 'Toyota', year: 2020 }\n\nconst myCar: CarType = {\n  make: 'Toyota',\n  year: 2020,\n} // ok\n\nconst neghboursCar: CarType = {\n  make: 'Honda', //Type '\"Honda\"' is not assignable to type '\"Toyota\"'.\n  year: 2015, //Type '2015' is not assignable to type '2020'.\n}",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "TypeScript's <ins>typeof</ins> is different than JavaScript's one. In JavaScript, <ins>typeof</ins> is an operator used at runtime to determine the type of a variable or expression. It is useful for checking the type of a value during the execution of code. In TypeScript, <ins>typeof</ins> is used in a type context to get the type of a variable or expression. It allows you to refer to the type of a value or expression at compile time, which is different from how <ins>typeof</ins> is used in JavaScript."
      },
      {
        "type": "Code",
        "value": "//In JavaScript:\nconst obj = { key: 'value' }\nconsole.log(typeof obj) // \"object\"\n\nconst arr = [1, 2, 3]\nconsole.log(typeof arr) // \"object\" (arrays are also objects in JS)\n\nconst func = () => {}\nconsole.log(typeof func) // \"function\"",
        "props": { "language": "javascript" }
      },
      {
        "type": "Code",
        "value": "//In TypeScript:\nconst obj = { key: 'value' }\ntype ObjType = typeof obj // ObjType is `{ key: string }`\n\nconst arr = [1, 2, 3]\ntype ArrType = typeof arr // ArrType is `number[]`\n\nconst func = () => {}\ntype FuncType = typeof func // FuncType is `() => void`",
        "props": { "language": "typescript" }
      }
    ]
  },
  {
    "title": "`keyof`",
    "data": [
      {
        "type": "Text",
        "value": "The <ins>keyof</ins> keyword in TypeScript creates a union of all the keys of a given object type. This is helpful when you need to restrict a value to the keys of a certain object."
      },
      {
        "type": "Code",
        "value": "interface Person {\n  name: string;\n  age: number\n}\ntype PersonKeys = keyof Person\n// PersonKeys is 'name' | 'age'",
        "props": { "language": "typescript" }
      },
      {
        "type": "Divider"
      },
      {
        "type": "Text",
        "value": "Take a look at this code:"
      },
      {
        "type": "Code",
        "value": "type Result = 'correct' | 'incorrect' | 'kindof'\n\nconst COLOR = {\n  RED: 'crimson',\n  GREEN: 'lime',\n  ORANGE: 'orange',\n} as const\n\nexport function setColor(result: Result): unknown {\n  if (result === 'correct') return COLOR.GREEN\n  if (result === 'incorrect') return COLOR.RED\n  if (result === 'kindof') return COLOR.ORANGE\n}",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "Here, the return type is <ins>unknown</ins> but we want it to be of type COLOR's value. We could use a union but this would make the code static. If COLOR changes, you'd need to manually update the function. Here is the proper way how to solve this problem:"
      },
      {
        "type": "Code",
        "value": "type Result = 'correct' | 'incorrect' | 'kindof'\n\nconst COLOR = {\n  RED: 'crimson',\n  GREEN: 'lime',\n  ORANGE: 'orange',\n} as const\n\nexport function setColor(result: Result): (typeof COLOR)[keyof typeof COLOR] {\n  if (result === 'correct') return COLOR.GREEN\n  if (result === 'incorrect') return COLOR.RED\n  if (result === 'kindof') return COLOR.ORANGE\n}",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "You are probably wondering what is going on."
      },
      {
        "type": "List",
        "value": [
          "Firstly, <ins>typeof COLOR</ins> gets the type of the <ins>COLOR</ins> object, which is a literal type of this form: <ins>{RED: 'crimson', GREEN: 'lime', ORANGE: 'orange'}</ins>.",
          "<ins>keyof typeof COLOR</ins> extracts the union of the keys of the <ins>COLOR</ins> object type. For the given <ins>COLOR</ins>, it would be <ins>'RED' | 'GREEN' | 'ORANGE'</ins>.",
          "Do you remember the syntax <ins>object[key]</ins> from \"Objects fundamentals\" lesson? <ins>(typeof COLOR)[keyof typeof COLOR]</ins> is essentially using that same syntax to dynamically access the type of values from the <ins>COLOR</ins> object based on its keys. "
        ]
      }
    ]
  },
  {
    "title": "Custom type guards",
    "data": [
      {
        "type": "Text",
        "value": "Type guards allow you to create functions that narrow down types based on some condition."
      },
      {
        "type": "Code",
        "value": "function isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nconst input: unknown = 'Hello'\n\nif (isString(input)) {\n  console.log(input.toUpperCase()) // TypeScript knows input is a string here\n}",
        "props": { "language": "typescript" }
      }
    ]
  },
  {
    "title": "Zod",
    "data": [
      {
        "type": "Text",
        "value": "In most cases, TypeScript is sufficient for type checking. However, if you need more rigorous validation, you can use a library such as Zod. Zod allows you to define validation schemas that can be used to validate data in real time. When data does not meet the schema requirements, Zod reports errors."
      },
      {
        "type": "Code",
        "value": "import { z } from 'zod'\n\nconst userSchema = z.object({\n  name: z.string().min(1), \n  age: z.number().int().positive(), \n  email: z.string().email(), \n})\n\nconst userData = {\n  name: 'Alice',\n  age: 30,\n  email: 'alice@example.com',\n}",
        "props": { "language": "typescript" }
      },
      {
        "type": "Text",
        "value": "An alternative to Zod could be Valibot."
      }
    ]
  }
]
