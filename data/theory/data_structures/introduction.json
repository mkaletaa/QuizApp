[
  {
    "title": "Primitive and complex types",
    "data": [
      {
        "type": "Text",
        "value": "So far in this app we've used some data structures like numbers and strings. They are primitive types which means they have only one property which is a value. We also explored a bit array and objects that are complex types. They may have multiple properties. Here are more examples of data structures in JS:"
      },
      {
        "type": "Image",
        "value": "",
        "props": { "description": "soon" }
      },
      {
        "type": "Text",
        "value": "We can define a variable in two ways. One of them is literal notation, where we directly assign a value to a variable using a literal value. For example, when we declare a string using quotes or a number directly, we are using literal notation:"
      },
      {
        "type": "Code",
        "value": "let name = \"John\"\nlet age = 28\nlet hobbies = ['swimming','programming','singing']\n\n//using a dot we can access properties of a complex type\nconsole.log(hobbies.length) // 3",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "The other way is by using a constructor function"
      },
      {
        "type": "Code",
        "value": "let name = new String('John')\nlet age = new Number(28)\nlet hobbies = new Array('swimming','programming','singing')",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "However, this approach is not advisable. The first reason is that it can make the code less readable, and the second reason is that variables created in this way are always of a complex type, which might lead to unexpected behavior."
      },
      {
        "type": "Code",
        "value": "{\n  let str1 = 'John'\n  let str2 = 'John'\n\n  console.log(str1 === str2) //true\n}\n\n{\n  let str1 = new String('John')\n  let str2 = new String('John')\n\n  console.log(str1 === str2) //false\n}",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "By the way, this is why some people are convinced that everything in JavaScript is an object. Now you know this is not true. The second reason why people might think that is that we can invoke certain properties and methods on primitive types, which is typically associated with complex types. For instance:"
      },
      {
        "type": "Code",
        "value": "let array = [1, 2, 3]\nconsole.log(array.length) // We access the 'length' property of an array\n\nlet string = \"Hello\"\nconsole.log(string.length) // We access the 'length' property of a string. But wait... primitive types have only one property which is their value. So why can we have access to another property?",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "The reason why this code works fine is that at the moment of accessing the length property, the string is temporarily converted to an object. This process is known as autoboxing. In JavaScript, primitive values like strings, numbers, and booleans do not inherently possess properties or methods. However, JavaScript can automatically convert these primitives into their corresponding object wrappers (e.g., String, Number, Boolean) when you attempt to access a property or method. <br></br>In other programming languages like Python this mechanism doesn't exist"
      },
      {
        "type": "Code",
        "value": "str = \"Hello\"\nprint(len(str)) # the way of getting a string length in Python",
        "props": { "language": "python" }
      }
    ]
  },
  {
    "title": "truthy and falsy",
    "data": [
      {
        "type": "Text",
        "value": "Another important classification of data structures involves their behavior in conditional contexts, distinguishing between truthy and falsy values. In JavaScript, any value can be evaluated in a boolean context, such as in conditionals or logical operations. Truthy values are those that evaluate to true when coerced to a boolean, while falsy values evaluate to false. Here are examples of falsy values:"
      },
      {
        "type": "Code",
        "value": "// here is an array of falsy values in JS:\nconst falsyValuesInJs = [\n  false, // false boolean\n  0, // 0 number\n  -0,\n  0n,\n  \"\", // empty strings\n  '',\n  ``,\n  NaN, // Not a Number\n  undefined,\n  null\n]",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "There is also '<a href='https://developer.mozilla.org/en-US/docs/Web/API/Document/all'>document.all</a>' value which is now archaic so you don't need to bother with it <br></br>The interesting thing about falsy values is that only primitive types can ba falsy."
      },
      {
        "type": "Code",
        "value": "const bool = new Boolean(false)\n\n// 'bool' variable has false value but as it was defined via constructor it is a complex type - therefore it cannot be falsy\nif (bool) {\n  console.log('bool is truthy') // 'bool is truthy'\n}",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "From the group of falsy values we can distinguish another group - nullish. It consists of undefined and null."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/c6qgBtPm/image.png",
        "props": {
          "description": "the difference between 0, null and undefined"
        }
      },
      {
        "type": "Text",
        "value": "<a href='https://while.dev/articles/dev/explaining-truthy-falsy-null-0-and-undefined-in-typescript/'>source</a> "
      }
    ]
  },
  {
    "title": "Type checking",
    "data": [
      {
        "type": "Header",
        "value": "typeof",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "Finding out a varable's type in JavaScript may be a tricky task. The most common way to do so is to use <b>typeof</b> keyword:"
      },
      {
        "type": "Code",
        "value": "let x = 42\nconsole.log(typeof x) // \"number\"\n\nlet y = 'Hello'\nconsole.log(typeof y) // \"string\"\n\nlet z = true\nconsole.log(typeof z) // \"boolean\"\n\nlet obj = {}\nconsole.log(typeof obj) // \"object\"\n\nlet func = function () {}\nconsole.log(typeof func) // \"function\"\n\nlet arr = []\nconsole.log(typeof arr) // \"object\" (arrays are objects in JavaScript)\n\nlet und\nconsole.log(typeof und) // \"undefined\"\n\nlet n = null\nconsole.log(typeof n) // \"object\" (this is a quirk in JavaScript)",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "TThere are some issues with this approach. typeof can be successfully used to find out simple types. However, when it comes to complex ones, it is not a good choice as it will almost always return 'object', which in some cases isn't precise enough. The only exception is functions. Yes, in JavaScript, functions are objects.<br></br>The other issue is the type of null is object. We know null is a primitive type. How can it be an object then? The reason for this is rooted in JavaScript's history. When JavaScript was first created, values were stored in a format that could encode both the type of the value and the actual data of the value. The type tag for objects was 0, and for null, it was 0 as well, which is why typeof null returns 'object'."
      },
      {
        "type": "Header",
        "value": "finding out complex types",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "We can find out if a variable is an array using Array.isArray()."
      },
      {
        "type": "Code",
        "value": "let variable1 = [1, 2, 3]\nlet variable2 = 123\n\nconsole.log(Array.isArray(variable1)) //true\nconsole.log(Array.isArray(variable2)) //false",
        "props": {"language": "javascript" }
      }
    ]
  }
]
