[
  {
    "title": "algebra Boole'a, zależności logiczne, parametry TTL",
    "data": [
      {
        "type": "Text",
        "value": "Teoria algebr Boole’a to dział matematyki z pogranicza algebry abstrakcyjnej, teorii porządku i logiki. Jest stosowana w różnych działach matematyki jak topologia, w informatyce teoretycznej i elektronice cyfrowej."
      },
      {
        "type": "Block",
        "value": [
          {
            "type": "Text",
            "value": "Działanie może mieć więcej niż jeden symbol. Tutaj musisz używać znaków +, * zamiast ∩ i ∪"
          }
        ],
        "props": {
          "type": "warning"
        }
      },
      {
        "type": "Header",
        "value": "łączność:",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`a+(b+c)=(a+b)+c`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Math",
        "value": "`a*(b*c)=(a*b)*c`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Header",
        "value": "przemienność:",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`a+b=b+a`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Math",
        "value": "`a*b=b*a`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Header",
        "value": "absorbcja:",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`a+(a*b)=a`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Math",
        "value": "`a*(a+b)=a`",
        "props": { "fontSize": 20 }
      },

      {
        "type": "Header",
        "value": "rozdzielność:",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`a+(b*c)=(a+b)*(a+c)`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Math",
        "value": "`a*(b+c)=(a*b)+(a*c)`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Header",
        "value": "pochłanianie:",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`a+overline a = 1`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Math",
        "value": "`a*overline a = 0`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Header",
        "value": "I prawo de Morgana:",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`overline(a*b)= overline a + overline b`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Header",
        "value": "II prawo de Morgana:",
        "props": { "size": "sm" }
      },
      {
        "type": "Math",
        "value": "`overline(a+b)= overline a * overline b`",
        "props": { "fontSize": 20 }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/hGLycJVf/image.png",
        "props": { "description": "Z tą tabelą są dwa problemy. Po pierwsze tam gdzie Uol i Uoh powinno być wyjście, a nie wejście. Po drugie na wykładzie było, że Uil jest 0 - 0.8, a Uih 2 - 5.", "orientation": "horizontal" }
      },
      {
        "type": "Text",
        "value": "I na tym można by zakończyć ten segment, ale u nas jeszcze zażyczył sobie podać definicję czasu propagacji i jak się go wyznacza. Zależności logicznych za to nie było wcale.<br></br><b>Czas propagacji</b> - czas jaki upływa między zmianą sygnału wejściowego a ustaleniem sygnału wyjściowego.<br></br>Nie wiem jak się go wyznacza, więc jak ktoś wie to pisać. Na wszelki wypadek wyjaśnię jeszcze inne pojęcia.<br></br><b>Maksymalna częstotliwość przełączania</b> - częstotliwość z jaką może zmieniać się sygnał na wejściu.<br></br><b>Obciążalność</b> - maksymalna liczba sygnałów wejściowych"
      }
    ]
  },
  {
    "title": "bramki logiczne, tablice prawdy, wzory, symbole, działanie",
    "data": [
      {
        "type": "Image",
        "value": "https://i.postimg.cc/8cbL9NSf/bramki.png",
        "props": { "orientation": "horizontal" }
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/KzdRtJ1q/image.png",
        "props": { "orientation": "horizontal" }
      },
      {
        "type": "Text",
        "value": "<b>AND</b> (I) realizuje funkcję iloczynu logicznego zmiennych wejściowych. Wyjście jest w stanie wysokim tylko jeśli oba wejścia są w stanie wysokim."
      },
      {
        "type": "Math",
        "value": "`Y=A*B`"
      },
      {
        "type": "Text",
        "value": "<b>OR</b> (LUB) realizuje funkcję sumy logicznej zmiennych wejściowych. Wyjście jest w stanie wysokim jeśli któreś z wejśćia (lub oba) jest w stanie wysokim."
      },
      {
        "type": "Math",
        "value": "`Y=A+B`"
      },
      {
        "type": "Text",
        "value": "<b>NOT</b> (NIE) układ o jednym wejściu, realizuje funkcję negacji zmiennej wejściowej. Gdy na wejściu jest 1, to na wyjściu jest 0; a gdy na wejściu jest 0, to na wyjściu jest 1."
      },
      {
        "type": "Math",
        "value": "`Y=overline A`"
      },
      {
        "type": "Text",
        "value": "<b>NAND</b> realizuje funkcję negacji iloczynu zmiennych wejściowych. Zero logiczne na wyjściu jest ustawiane tylko gdy na obu wejściach jest 1. W pozostałych przypadkach na wyjściu jest zawsze 1."
      },
      {
        "type": "Math",
        "value": "`Y=overline (A*B)`"
      },
      {
        "type": "Text",
        "value": "<b>NOR</b> realizuje negację sumy sygnałów wejściowych. Zero na wyjściu pojawia się zawsze wtedy, gdy na przynajmniej jednym z wejść pojawia się jedynka logiczna. Tylko wtedy gdy wszystkie wejścia ustawione są na 0, na wyjściu pojawia się jedynka."
      },
      {
        "type": "Math",
        "value": "`Y=overline (A+B)`"
      },
      {
        "type": "Text",
        "value": "<b>EXOR/XOR</b> (ALBO) wyjście jest w stanie wysokim (1) jeśli stany wejść są różne."
      },
      {
        "type": "Math",
        "value": "`Y=Ao+B`"
      },
      {
        "type": "Text",
        "value": "<b>EXNOR/XNOR</b> (NIE ALBO) wyjście jest w stanie wysokim (1) jeśli stany wejść są równe."
      },
      {
        "type": "Math",
        "value": "`Y=overline (Ao+B)`"
      }
    ]
  },
  {
    "title": "budowa bramki NAND TTL, cha-ka przełączenia",
    "data": [
      {
        "type": "Text",
        "value": "To jest na 5 więc wyjebane"
      }
    ]
  },
  {
    "title": "realizacja funkcji logicznych na dowolnych 2-WE bramkach",
    "data": [
      {
        "type": "Text",
        "value": "Trzeba było narysować schemat dla takiej funkcji:"
      },
      {
        "type": "Math",
        "value": "`overlineoverline(ABoverlineC)+overline(A+overline(overlineB+C))+C`"
      },
      {
        "type": "Block",
        "value": [
          {
            "type": "Text",
            "value": "Ja w tym tutorialu tego nie zrobiłem, ale tam gdzie bramka NOT występuje bezpośrednio po AND lub OR używaj bramek NAND i NOR. <br></br>Pamiętaj też o podpisywaniu bramek wzorami, bo trzech typów polegało na tym że tego nie zrobili"
          }
        ],
        "props": {
          "type": "warning"
        }
      },
      {
        "type": "Text",
        "value": "Każda bramka może mieć co najwyżej 2 wejścia. Dla ambitnych jest zrobienie tego za pomocą samych bramek NAND, ale my nie jesteśmy ambitni. Obowiązuje taka sama kolejność działań jak na matematyce czyli najpierw to co w nawiasach (negacja), potem mnożenie i potem dodawanie. Zaczniemy od wyrażenia po lewej. Normalnie moglibyśmy narysować tak:"
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/bw2TfG16/image.png",
        "props": {"description":"tutaj nie powinno być tych kółek koło wejść A, B i C, ale nie wiedziałem jak się ich pozbyć", "orientation": "horizontal" }
      },
      {
        "type": "Text",
        "value": "Ale jest wymóg, żeby były maksymalnie 2 wejścia, a tutaj są 3. Trzeba więc tę bramkę rozbić na dwie. Jako że mnożenie jest przemienne nie ma znaczenia czy najpierw pomnożymy A z B czy B z ~C, czy A z ~C. Ja najpierw pomnożę B z ~C, a potem A z B~C."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/ncN42HNq/image.png"
      },
      {
        "type": "Text",
        "value": "Teraz jeszcze tylko podwójne negacja i całe wyrażenie po lewej załatwione."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/zf8R237H/image.png"
      },
      {
        "type": "Text",
        "value": "Teraz zajmijmy się środkowym wyrażeniem. Tutaj już nie ma wyboru kolejności."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/3rFxr7XY/image.png",
        "props": { "orientation": "horizontal" }
      },
      {
        "type": "Text",
        "value": "Na koniec zostało zsumować oba te wyrażenia z C. Kolejność nie ma znaczenia, ja najpierw zsumuję środkowe z C, a potem z pierwszym."
      },
      {
        "type": "Image",
        "value": "https://i.postimg.cc/QCw4GvxP/image.png",
        "props": { "orientation": "horizontal" }
      },
      {
        "type": "Text",
        "value": "Schematy stworzone za pomocą <a href='https://circuitverse.org/'>circuitverse.org</a>"
      },
      {
        "type": "Block",
        "value": [
          {
            "type": "Text",
            "value": "Na poprawie była taka funkcja:"
          },
          {
            "type": "Math",
            "value": "`overline(overlineaboverlinec)+overline(overline(aoverlineb)+c)*overlined`"
          },
          {
            "type": "Text",
            "value": "Narysuj do niej schemat, a później wejdź w poniższy link i sprawdź czy masz dobrze <br></br> <a href='https://i.postimg.cc/8C7vCH4m/IMG-20240515-124103.jpg'>Link</a> "
          }
        ],
        "props": {
          "type": "task"
        }
      }
    ]
  }
]
