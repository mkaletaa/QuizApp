[
  {
    "title": "",
    "data": [
      {
        "type": "Text",
        "value": "Error handling in programming involves managing errors or exceptions that occur during the execution of a program, ensuring that they are dealt with gracefully without crashing the application. In JavaScript, error handling is primarily managed using <ins>try-catch</ins> blocks, custom error objects, and the <ins>throw</ins> statement. It allows developers to anticipate errors and handle them appropriately, preventing the program from crashing unexpectedly."
      },

      {
        "type": "Header",
        "value": "try...catch Statement",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "The <ins>try-catch</ins> statement allows you to test a block of code for errors and handle them. If an error occurs within the <ins>try</ins> block, control is immediately passed to the <ins>catch</ins> block."
      },
      {
        "type": "Code",
        "value": "try {\n  // Code that may throw an error\n  let result = riskyOperation();\n  console.log(result);\n} catch (error) {\n  // Handle the error\n  console.error('An error occurred:', error.message);\n}",
        "props": { "language": "javascript" }
      },
      {
        "type": "Header",
        "value": "Finally block",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "The <ins>finally</ins> block can be used after <ins>try-catch</ins> to execute code regardless of whether an error was thrown or not. It's useful for cleanup operations."
      },
      {
        "type": "Code",
        "value": "try {\n  let result = riskyOperation();\n  console.log(result);\n} catch (error) {\n  console.error('An error occurred:', error.message);\n} finally {\n  console.log('Cleanup code runs here, regardless of an error.');\n}",
        "props": { "language": "javascript" }
      },
      {
        "type": "Header",
        "value": "Throwing errors",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "The <ins>throw</ins> statement allows you to create a custom error and interrupt the normal flow of the program. You can throw any type of data, but it's best practice to throw <ins>Error</ins> objects."
      },
      {
        "type": "Code",
        "value": "function riskyOperation() {\n  if (somethingGoesWrong) {\n    throw new Error('A problem occurred');\n  }\n  return 'Success';\n}\n\ntry {\n  riskyOperation();\n} catch (error) {\n  console.error(error.message);\n}",
        "props": { "language": "javascript" }
      },
      {
        "type": "Header",
        "value": "Asynchronous error handling",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "Handling errors in asynchronous code (such as promises) requires different approaches. Use <ins>.catch()</ins> for promises and try to always handle rejection."
      },
      {
        "type": "Code",
        "value": "fetchData()\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('An error occurred:', error));",
        "props": { "language": "javascript" }
      },
      {
        "type": "Header",
        "value": "Custom Errors",
        "props": { "size": "sm" }
      },
      {
        "type": "Text",
        "value": "In JavaScript, you can create custom error types by extending the <ins>Error</ins> class. This is useful for defining specific errors related to your application domain."
      },
      {
        "type": "Code",
        "value": "class CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'CustomError';\n  }\n}\n\ntry {\n  throw new CustomError('Something went wrong!');\n} catch (error) {\n  console.error(error.name); // 'CustomError'\n  console.error(error.message); // 'Something went wrong!'\n}",
        "props": { "language": "javascript" }
      },
      {
        "type": "Header",
        "value": "Common Best Practices",
        "props": { "size": "sm" }
      },
      {
        "type": "List",
        "value": [
          "<b>Graceful Degradation</b>: Ensure that when an error occurs, the application can still function in some capacity.",
          "<b>Logging Errors</b>: Keep a record of errors, especially in production environments, for debugging and monitoring.",
          "<b>User-Friendly Messages</b>: Display meaningful error messages to users without exposing sensitive information.",
          "<b>Validation</b>: Validate input data to catch errors early and prevent invalid data from causing issues."
        ]
      }
    ]
  }
]
