[
  {
    "title": "",
    "data": [
      {
        "type": "Text",
        "value": "The execution context in JavaScript is an abstract concept that represents the environment in which code is executed. It contains everything necessary to execute a piece of code, including the variables, the <ins>this</ins> keyword, the outer environment reference, and the code currently being executed."
      }
    ]
  },
  {
    "title": "`this` keyword",
    "data": [
      {
        "type": "Text",
        "value": "<ins>this</ins> tells the context.<br></br>When we run code outside of any function, the context is the global object, which is <ins>window</ins> in browsers and <ins>global</ins> in Node.js."
      },
      {
        "type": "Code",
        "value": "console.log(this); // window",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "If code is run inside an object method, `<ins>this</ins> refers to the object the method belongs to."
      },
      {
        "type": "Code",
        "value": "const obj = {\n  name: 'Alice',\n  greet() {\n    console.log(this.name); // 'Alice'\n  }\n};\nobj.greet();",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "If a method is defined inside a nested object, <ins>this</ins> refers to the nearest object the method is called on."
      },
      {
        "type": "Code",
        "value": "const outerObj = {\n  innerObj: {\n    name: 'Bob',\n    greet() {\n      console.log(this.name); // 'Bob'\n    }\n  }\n};\nouterObj.innerObj.greet();",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "For arrow functions, <ins>this</ins> is determined by the surrounding (lexical) scope at the time of the function's creation. Arrow functions do not have their own <ins>this</ins>, so they inherit it from the outer context."
      },
      {
        "type": "Code",
        "value": "const obj = {\n  name: 'Charlie',\n  greet: () => {\n    console.log(this); // window/global\n  }\n}\n\nobj.greet();",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "For regular functions, the value of <ins>this</ins> depends on how the function is called. Normally, <ins>this</ins> in functions refers to the global object when called in a non-method context."
      },
      {
        "type": "Code",
        "value": "function init() {\n  console.log(this); // window (or global in Node.js)\n}\ninit();",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "However, in strict mode, <ins>this</ins> is <ins>undefined</ins> in standalone functions."
      },
      {
        "type": "Code",
        "value": "'use strict'\n\nfunction init() {\n  console.log(this); // undefined\n}\ninit();",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "When a function is defined within an object but not as a method, it still behaves like a standalone function. If such a function is called without an object context, <ins>this</ins> will refer to the global object in non-strict mode, or <ins>undefined</ins> in strict mode."
      },
      {
        "type": "Code",
        "value": "const obj = {\n  age: 120,\n  show: function() {\n    console.log(this); // Points to obj\n  },\n  innerFunc: function() {\n    function notAMethod() {\n      console.log(this); // window (or global in Node.js) in non-strict mode, undefined in strict mode\n    }\n    notAMethod();\n  }\n};\nobj.show();\nobj.innerFunc();",
        "props": { "language": "javascript" }
      }
    ]
  },
  {
    "title": "apply(), call(), bind()",
    "data": [
      {
        "type": "Text",
        "value": "The <ins>apply</ins>, <ins>call</ins>, and <ins>bind</ins> methods are used to manipulate the context. These methods are particularly useful when you want to borrow methods from other objects or control the execution context of a function."
      },
      {
        "type": "Header",
        "value": "apply()",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "The <ins>apply()</ins> method calls a function with a given <ins>this</ins> value, and arguments provided as an array (or an array-like object). This allows you to pass arguments to a function in a flexible way, especially useful when the number of arguments is not known beforehand."
      },
      {
        "type": "Block",
        "value": [
          {
            "type": "Text",
            "value": "You can use a mnemonic to remember that <ins>apply()</ins> takes an array of arguments because both \"apply\" and \"array\" start with the same letter."
          }
        ],
        "props": {
          "type": "tip"
        }
      },
      {
        "type": "Code",
        "value": "const person = { name: 'Alice' };\n\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\ngreet.apply(person, ['Hello', '!']); // Output: Hello, Alice!",
        "props": { "language": "javascript" }
      },
      {
        "type": "Header",
        "value": "call()",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "The <ins>call()</ins> method also calls a function with a given <ins>this</ins> value, but arguments are provided individually. This method is useful when you know the exact number and order of arguments you need to pass."
      },
      {
        "type": "Code",
        "value": "const person = { name: 'Bob' };\n\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\ngreet.call(person, 'Hi', '.'); // Output: Hi, Bob.",
        "props": { "language": "javascript" }
      },
      {
        "type": "Header",
        "value": "bind()",
        "props": { "size": "md" }
      },
      {
        "type": "Text",
        "value": "The <ins>bind()</ins> method creates a new function (called in JS jargon a 'bound function') that, when called, has its <ins>this</ins> set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. This method is particularly useful for setting the context in event handlers or callbacks."
      },
      {
        "type": "Code",
        "value": "const person = {name: 'Nick'}\n\nfunction greet(greeting, punctuation){\n  console.log(greeting + ', '+ this.name + punctuation)\n}\n\nconst boundGreet = greet.bind(person, 'Hey', '!')\nboundGreet() //Output: Hey, Nick!\n\n//We don't have to pass the other arguments to the bind()\nconst boundGreetWithoutArgs = greet.bind(person)\n//We can do it at the moment of calling the bound function\nboundGreetWithoutArgs('Hi', '?') //Output: Hi, Nick?",
        "props": { "language": "javascript" }
      },
      {
        "type": "Text",
        "value": "In summary, <ins>apply()</ins> is suitable for arguments as an array, <ins>call()</ins> for individual arguments, and <ins>bind()</ins> for creating a new function with a preset <ins>this</ins> value. Notice, normally the greet function has a global context but thanks to these three special functions we changed its context to another object for a moment."
      }
    ]
  }
]
